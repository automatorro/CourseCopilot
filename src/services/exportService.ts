import PptxGenJS from 'pptxgenjs';
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, Header, ImageRun, Table, TableRow, TableCell, WidthType, BorderStyle } from 'docx';
import JSZip from 'jszip';

import { Course, CourseStep, SlideModel, SlideArchetype, SlideRules } from '../types';
import { replaceBlobUrlsWithPublic, ensurePublicExternalImages } from './imageService';
import { isEnabled } from '../config/featureFlags';
import { exportCourseAsPdf } from './pdfExporter';

// ============================================================================
// TYPES & INTERFACES
// ============================================================================

interface ContentSection {
    title: string;
    bulletPoints: string[];
    images: { url: string; alt: string }[];
    rawContent: string;
    bodyText?: string;
}

const normalizeExternalImageLinks = (md: string): string => {
    try {
        let out = md;
        out = out.replace(/https?:\/\/unsplash\.com\/photos\/[\S)]+/gi, (m) => {
            const last = (m.split('/').pop() || '').split('?')[0];
            const id = last.includes('-') ? (last.split('-').pop() || last) : last;
            return `https://source.unsplash.com/${id}/1600x900`;
        });
        out = out.replace(/https?:\/\/(?:www\.)?pexels\.com\/photo\/[\w-]*?(\d+)\/?/gi, (_m: string, id: string) => {
            const safeId = String(id);
            return `https://images.pexels.com/photos/${safeId}/pexels-photo-${safeId}.jpeg?auto=compress&cs=tinysrgb&w=1600&h=900`;
        });
        out = out.replace(/https?:\/\/(?:www\.)?pixabay\.com\/photos\/[\w-]*?(\d+)\/?/gi, (_m: string, id: string) => {
            const safeId = String(id);
            return `https://cdn.pixabay.com/photo/${safeId}_1280.jpg`;
        });
        return out;
    } catch {
        return md;
    }
};

// ============================================================================
// HELPER FUNCTIONS - SLIDE GENERATORS
// ============================================================================

const addTitleSlide = (pptx: PptxGenJS, course: Course): void => {
    const slide = pptx.addSlide();
    slide.background = { color: '1E3A8A' };

    slide.addText(course.title, {
        x: 0.5, y: 2, w: '90%', h: 1.5,
        fontSize: 44, bold: true, color: 'FFFFFF',
        align: 'center'
    });

    slide.addText(course.subject, {
        x: 0.5, y: 3.5, w: '90%', h: 0.8,
        fontSize: 24, color: 'E5E7EB',
        align: 'center'
    });

    slide.addText('Generated by AI Course Co-Pilot', {
        x: 0.5, y: 6.5, w: '90%', h: 0.3,
        fontSize: 12, color: '9CA3AF',
        align: 'center', italic: true
    });
};

const addAgendaSlide = (
    pptx: PptxGenJS,
    course: Course,
    structureStep: CourseStep | null,
    videoScriptStep: CourseStep | null
): void => {
    const slide = pptx.addSlide();

    slide.addText('Structura Cursului', {
        x: 0.5, y: 0.5, w: '90%', h: 0.8,
        fontSize: 32, bold: true, color: '1F2937'
    });

    const modules = structureStep
        ? parseModulesFromStructure(structureStep.content)
        : generateModulesFromSteps(course.steps || []);

    slide.addText(modules, {
        x: 0.5, y: 1.5, w: '90%', h: 5,
        fontSize: 18, bullet: true, color: '374151',
        lineSpacing: 28
    });

    if (videoScriptStep) {
        const introScript = extractIntroScript(videoScriptStep.content);
        if (introScript) {
            slide.addNotes(introScript);
        }
    }
};

const addContentSlides = async (
    pptx: PptxGenJS,
    step: CourseStep,
    course: Course,
    videoScripts: Record<string, string>
): Promise<void> => {
    const pre = normalizeExternalImageLinks(step.content);
    const withPublic = await replaceBlobUrlsWithPublic(pre, course.user_id, course.id);
    const sections = parseContentSections(withPublic);

    for (const section of sections) {
        const slide = pptx.addSlide();

        slide.addText(section.title, {
            x: 0.5, y: 0.5, w: '90%', h: 0.8,
            fontSize: 28, bold: true, color: '1F2937'
        });

        if (section.bulletPoints.length > 0) {
            const bulletText = section.bulletPoints.join('\n');
            slide.addText(bulletText, {
                x: 0.5, y: 1.5, w: '90%', h: 4,
                fontSize: 18, bullet: true, color: '374151',
                lineSpacing: 28
            });
        } else if (section.bodyText) {
            slide.addText(section.bodyText, {
                x: 0.5, y: 1.5, w: '90%', h: 4.8,
                fontSize: 20, color: '374151',
                lineSpacing: 28
            });
        }

        if (section.images.length > 0) {
            const yPos = 5.5;
            for (const img of section.images.slice(0, 1)) {
                try {
                    let dataUrl: string | null = null;
                    if (img.url.startsWith('http')) {
                        dataUrl = await fetchToDataUrl(img.url);
                    }
                    const isData = img.url.startsWith('data:') || !!dataUrl;
                    const opts: PptxGenJS.ImageProps = isData
                        ? { data: dataUrl || img.url, x: 0.5, y: yPos, w: 8, h: 1.5 }
                        : img.url.startsWith('http')
                            ? { path: img.url, x: 0.5, y: yPos, w: 8, h: 1.5 }
                            : null as unknown as PptxGenJS.ImageProps;
                    if (!opts) continue;
                    slide.addImage(opts);
                } catch (e) {
                    console.warn('Failed to add image:', e);
                }
            }
        }

        const matchingScript = findMatchingScript(videoScripts, section.title);
        if (matchingScript) {
            slide.addNotes(matchingScript);
        }

        slide.addText(`${course.title} | ${new Date().toLocaleDateString()}`, {
            x: 0.5, y: 6.8, w: '90%', h: 0.3,
            fontSize: 10, color: '9CA3AF', align: 'right'
        });
    }
};

const addSummarySlide = (pptx: PptxGenJS): void => {
    const slide = pptx.addSlide();
    slide.background = { color: 'F3F4F6' };

    slide.addText('Recapitulare', {
        x: 0.5, y: 1.5, w: '90%', h: 1,
        fontSize: 36, bold: true, color: '1F2937',
        align: 'center'
    });

    const summaryText = [
        'Mulțumim pentru participare!',
        'Continuați cu proiectele practice',
        'Descărcați cheat sheet-ul pentru referință rapidă',
        'Aplicați tehnicile învățate în următoarele 48h'
    ].join('\n');

    slide.addText(summaryText, {
        x: 0.5, y: 3, w: '90%', h: 3,
        fontSize: 20, bullet: true, color: '374151',
        align: 'center', lineSpacing: 32
    });
};

const fetchToDataUrl = async (url: string): Promise<string | null> => {
    try {
        const res = await fetch(url);
        if (!res.ok) return null;
        const blob = await res.blob();
        return await new Promise<string>((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result as string);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    } catch {
        return null;
    }
};

// ============================================================================
// PARSER FUNCTIONS
// ============================================================================

const parseContentSections = (markdown: string): ContentSection[] => {
    const sections: ContentSection[] = [];
    const lines = markdown.split('\n');
    let currentTitle: string | null = null;
    let currentBullets: string[] = [];
    let currentImages: { url: string; alt: string }[] = [];
    let currentRaw: string[] = [];
    const flush = () => {
        if (!currentTitle) {
            currentRaw = [];
            return;
        }
        const rawJoined = normalizeMarkdownImages(currentRaw.join('\n'));
        const htmlImgs = Array.from(rawJoined.matchAll(/<img[\s\S]*?src=["']([^"']+)["'][\s\S]*?>/ig));
        htmlImgs.forEach(m => {
            const url = m[1];
            const altMatch = (m[0].match(/alt=["']([^"']*)["']/i) || [null, '']);
            const alt = altMatch[1] || '';
            currentImages.push({ url, alt });
        });
        const plainImgs = Array.from(rawJoined.matchAll(/(https?:\/\/[^\s)]+?\.(?:png|jpe?g|gif|webp)(?:\?[^\s)]*)?)/ig));
        plainImgs.forEach(m => {
            const url = m[1];
            currentImages.push({ url, alt: '' });
        });
        const bodyLines = rawJoined.split('\n').filter(l => {
            const t = l.trim();
            if (!t) return false;
            if (t.startsWith('## ')) return false;
            if (/^\*\s|^-\s|^\d+\.\s|^•\s/.test(t)) return false;
            if (/!\[[^\]]*\]\([^)]+\)/.test(t)) return false;
            if (/<img[^>]*>/i.test(t)) return false;
            return true;
        });
        const bodyText = bodyLines.join('\n').trim() || undefined;
        sections.push({ title: currentTitle, bulletPoints: currentBullets, images: currentImages, rawContent: rawJoined, bodyText });
        currentTitle = null;
        currentBullets = [];
        currentImages = [];
        currentRaw = [];
    };
    for (const raw of lines) {
        const line = raw.trim();
        const isH2 = line.startsWith('## ');
        const isBoldTitle = line.startsWith('**') && line.endsWith('**') && line.length > 4;
        if (isH2 || isBoldTitle) {
            flush();
            let t = isH2 ? line.substring(3) : line.substring(2, line.length - 2);
            t = t.replace(/^Slide\s*\d+\s*:\s*/i, '').trim();
            currentTitle = t;
            continue;
        }
        currentRaw.push(raw);
        if (line.startsWith('* ') || line.startsWith('- ') || /^\d+\.\s/.test(line) || line.startsWith('• ')) {
            let b = line.substring(2).trim();
            b = b.replace(/\*\*|__|`/g, '').trim();
            if (b.length > 0) currentBullets.push(b);
            continue;
        }
        const mdImg = line.match(/!\[([^\]]*)\]\(([^)]+)\)/);
        if (mdImg) {
            currentImages.push({ alt: mdImg[1], url: mdImg[2] });
            continue;
        }
        const htmlImg = line.match(/<img[^>]*src=["']([^"']+)["'][^>]*alt=["']?([^"']*)["']?[^>]*>/i);
        if (htmlImg) {
            currentImages.push({ alt: htmlImg[2] || '', url: htmlImg[1] });
            continue;
        }
    }
    flush();
    return sections.filter(s => !!s.title);
};

const parseVideoScripts = (markdown: string): Record<string, string> => {
    const scripts: Record<string, string> = {};
    const lessons = markdown.split(/\n(?=## )/);

    for (const lesson of lessons) {
        const titleMatch = lesson.match(/^##\s*(.+)/m);
        if (!titleMatch) continue;

        const title = titleMatch[1].trim();
        const audioMatches = lesson.matchAll(/\[AUDIO\]\s*(.+?)(?=\[VISUAL\]|\n\n|$)/gs);
        const audioContent = Array.from(audioMatches)
            .map(m => m[1].trim())
            .join('\n\n');

        if (audioContent) {
            scripts[title] = audioContent;
        }
    }

    return scripts;
};

const findMatchingScript = (
    scripts: Record<string, string>,
    slideTitle: string
): string | null => {
    if (scripts[slideTitle]) {
        return scripts[slideTitle];
    }

    const keywords = slideTitle.toLowerCase().split(' ').filter(w => w.length > 3);
    for (const [scriptTitle, content] of Object.entries(scripts)) {
        const matches = keywords.filter(kw =>
            scriptTitle.toLowerCase().includes(kw)
        );
        if (matches.length >= 2) {
            return content;
        }
    }

    return null;
};

const extractIntroScript = (markdown: string): string => {
    const introMatch = markdown.match(/\[AUDIO\]\s*(.+?)(?=\[VISUAL\]|\n##|$)/s);
    return introMatch ? introMatch[1].trim() : '';
};

const parseModulesFromStructure = (markdown: string): string => {
    const lines = markdown.split('\n');
    const modules: string[] = [];

    for (const line of lines) {
        if (line.match(/^(Modul|Module)\s+\d+:/i)) {
            modules.push(line.trim());
        } else if (line.match(/^\s*[*-]\s+\*\*Lecția/i)) {
            modules.push('  ' + line.trim().replace(/^\s*[*-]\s+/, ''));
        }
    }

    return modules.length > 0 ? modules.join('\n') : 'Structura cursului va fi detaliată în lecțiile următoare.';
};

const generateModulesFromSteps = (steps: CourseStep[]): string => {
    return steps
        .filter(s => !shouldExcludeFromSlides(s))
        .map((s, i) => `${i + 1}. ${s.title_key}`)
        .join('\n');
};

const shouldExcludeFromSlides = (step: CourseStep): boolean => {
    const excludedKeys = ['structure', 'video_scripts', 'tests', 'cheat_sheets'];
    return excludedKeys.some(key => step.title_key.toLowerCase().includes(key));
};

const findStepByKey = (course: Course, keyPattern: string): CourseStep | null => {
    return course.steps?.find(s =>
        s.title_key.toLowerCase().includes(keyPattern.toLowerCase())
    ) || null;
};

// ============================================================================
// MAIN EXPORT FUNCTIONS
// ============================================================================

export const exportCourseAsPptx = async (course: Course): Promise<void> => {
    if (isEnabled('newPptxExporter')) {
        try {
            await exportCourseAsPptxV2(course);
            return;
        } catch (e) {
            console.warn('[Export] V2 exporter failed, falling back to legacy:', e);
        }
    }
    const pptx = new PptxGenJS();
    pptx.layout = 'LAYOUT_16x9';

    addTitleSlide(pptx, course);

    const structureStep = findStepByKey(course, 'structure');
    const videoScriptStep = findStepByKey(course, 'video_scripts');
    addAgendaSlide(pptx, course, structureStep, videoScriptStep);

    const videoScripts = videoScriptStep
        ? parseVideoScripts(videoScriptStep.content)
        : {};

    for (const step of course.steps || []) {
        if (!shouldExcludeFromSlides(step) && step.content) {
            await addContentSlides(pptx, step, course, videoScripts);
        }
    }

    addSummarySlide(pptx);

    const fileName = `${course.title.replace(/[^a-z0-9]/gi, '_')}.pptx`;
    await pptx.writeFile({ fileName });
};

const linkSlideModelsToBlueprint = (course: Course, models: SlideModel[]): SlideModel[] => {
    const bp = course.blueprint;
    if (!bp || !Array.isArray(bp.modules)) return models;
    const byTitle: Record<string, { sectionId: string; objective: string }> = {};
    for (const m of bp.modules) {
        for (const s of m.sections || []) {
            const k = (s.title || '').toLowerCase().trim();
            if (!k) continue;
            byTitle[k] = { sectionId: s.id, objective: m.learning_objective };
        }
    }
    return models.map(mm => {
        const t = (mm.title || '').toLowerCase().trim();
        const link = byTitle[t];
        if (!link) return mm;
        const objective_links = Array.isArray(mm.objective_links) ? mm.objective_links : [];
        const nextObj = link.objective ? [link.objective] : objective_links;
        return { ...mm, section_id: link.sectionId, objective_links: nextObj };
    });
};

export const getSlideModelsForPreview = async (course: Course): Promise<SlideModel[]> => {
    const slidesStep = findStepByKey(course, 'course.livrables.slides');
    const videoScriptStep = findStepByKey(course, 'video_scripts');
    const scripts = videoScriptStep ? parseVideoScripts(videoScriptStep.content) : {};
    if (slidesStep && slidesStep.content) {
        const contentWithPublic = await replaceBlobUrlsWithPublic(slidesStep.content, course.user_id, course.id);
        let models = buildSlideModelsFromContent(contentWithPublic, slidesStep.title_key, scripts);
        models = linkSlideModelsToBlueprint(course, models);
        return models;
    }
    let models = buildSlideModelsFromCourse(course, scripts);
    models = linkSlideModelsToBlueprint(course, models);
    return models;
};

export const getPedagogicWarnings = (m: SlideModel): string[] => {
    const rules = getTemplateRules(m.slide_type);
    const warnings: string[] = [];
    const titleLen = (m.title || '').length;
    if (rules.maxTitleChars && titleLen > rules.maxTitleChars) warnings.push('[WARN] Titlu prea lung pentru arhetip');
    const bullets = m.bullets || [];
    if (rules.maxBullets && bullets.length > rules.maxBullets) warnings.push('[WARN] Prea multe bullets');
    const maxLen = rules.maxBulletLength ?? null;
    if (maxLen !== null && bullets.some(b => b.length > maxLen)) warnings.push('[WARN] Bullets prea lungi');

    const density = ((m.title || '').length) + bullets.reduce((acc, b) => acc + b.length, 0);
    if (density > 1000) warnings.push('[WARN] Conținut prea dens pentru un singur slide');

    if (m.slide_type === SlideArchetype.ImageText && !m.image_url) warnings.push('[CRITICAL] Lipsește imaginea la Image+Text');

    const textAll = ((m.title || '') + ' ' + bullets.join(' ')).toLowerCase();
    const BLOOM = {
        remember: ['definește', 'defini', 'enumeră', 'listează', 'identifică', 'recunoaște', 'descrie', 'menționează'],
        understand: ['explică', 'interpretează', 'clarifică', 'rezumă', 'exemplifică', 'parafrazează', 'ilustrează'],
        apply: ['aplică', 'utilizează', 'folosește', 'implementează', 'exersează', 'execută', 'proiectează', 'realizează'],
        analyze: ['analizează', 'compară', 'descompune', 'relatează', 'examinează', 'categorizează', 'corelează'],
        evaluate: ['evaluează', 'argumentează', 'justifică', 'critică', 'decide', 'apreciază', 'verifică'],
        create: ['creează', 'sintetizează', 'compune', 'inovează', 'construiește', 'elaborează', 'proiectează']
    } as const;
    const bloomOrder = ['remember', 'understand', 'apply', 'analyze', 'evaluate', 'create'] as const;
    const detectBloomLevel = (t: string): number => {
        for (let i = bloomOrder.length - 1; i >= 0; i--) {
            const level = bloomOrder[i];
            const verbs = BLOOM[level];
            if (verbs.some(v => t.includes(v))) return i;
        }
        return -1;
    };
    const minLevelForArchetype = (a: SlideArchetype): number => {
        if (a === SlideArchetype.Exercise) return bloomOrder.indexOf('apply');
        if (a === SlideArchetype.CaseStudy) return bloomOrder.indexOf('analyze');
        if (a === SlideArchetype.Summary) return bloomOrder.indexOf('understand');
        if (a === SlideArchetype.Explainer) return bloomOrder.indexOf('understand');
        if (a === SlideArchetype.ImageText) return bloomOrder.indexOf('understand');
        return bloomOrder.indexOf('remember');
    };
    const bloomDetected = detectBloomLevel(textAll);
    const bloomRequired = minLevelForArchetype(m.slide_type);
    if (bloomDetected >= 0 && bloomDetected < bloomRequired) warnings.push('[WARN] Nivel Bloom prea scăzut pentru arhetip');

    if (m.slide_type === SlideArchetype.Exercise) {
        if (bullets.length < 3) warnings.push('[CRITICAL] Exercițiu fără pași suficienți');
        const hasApply = BLOOM.apply.some(v => textAll.includes(v));
        if (!hasApply) warnings.push('[WARN] Exercițiul ar trebui să ceară aplicare');
    }

    if (m.slide_type === SlideArchetype.CaseStudy) {
        const keys = ['context', 'problemă', 'soluție', 'rezultat'];
        const hits = keys.filter(k => textAll.includes(k)).length;
        if (hits < 2) warnings.push('[WARN] Studiu de caz fără structură clară');
        const hasEvaluate = BLOOM.evaluate.some(v => textAll.includes(v));
        if (!hasEvaluate) warnings.push('[INFO] Adaugă evaluare/concluzii pentru un studiu de caz robust');
    }

    if (m.slide_type === SlideArchetype.Summary) {
        const integrationHints = ['reflectă', 'plan', 'transfer', 'integrează', 'recapitulare', 'reține'];
        const hasIntegration = integrationHints.some(v => textAll.includes(v));
        if (!hasIntegration) warnings.push('[INFO] Îndeamnă la reflecție/plan de acțiune în rezumat');
    }

    return warnings;
};

const splitSentences = (text: string): string[] => {
    const clean = text.replace(/\s+/g, ' ').trim();
    if (!clean) return [];
    const parts = clean.split(/(?<=[.!?])\s+/);
    return parts.map(p => p.replace(/^[*•-]\s*/, '').trim()).filter(Boolean);
};

const deriveBulletsFromBody = (body: string): string[] => {
    const sents = splitSentences(body);
    return sents.slice(0, 6);
};

const getImageDims = (url: string): Promise<{ w: number; h: number }> => {
    return new Promise((resolve) => {
        try {
            const img = new Image();
            img.onload = () => resolve({ w: img.naturalWidth || 1600, h: img.naturalHeight || 900 });
            img.onerror = () => resolve({ w: 1600, h: 900 });
            img.src = url;
        } catch {
            resolve({ w: 1600, h: 900 });
        }
    });
};

const fitContain = (boxW: number, boxH: number, imgW: number, imgH: number): { w: number; h: number } => {
    const scale = Math.min(boxW / imgW, boxH / imgH);
    return { w: Math.max(0.1, imgW * scale), h: Math.max(0.1, imgH * scale) };
};

// V2 exporter: builds SlideModel IR and renders archetypes deterministically
const buildSlideModelsFromCourse = (course: Course, scripts: Record<string, string>): SlideModel[] => {
    const models: SlideModel[] = [];
    const steps = course.steps || [];
    for (const step of steps) {
        if (shouldExcludeFromSlides(step) || !step.content) continue;
        const sections = parseContentSections(step.content);
        sections.forEach((s, idx) => {
            const id = `${step.id}_sec_${idx + 1}`;
            const baseBullets = s.bulletPoints.length > 0 ? s.bulletPoints : deriveBulletsFromBody(s.bodyText || '');
            const image = s.images[0]?.url || null;
            const archetype = chooseArchetypeFor(step.title_key, s.title, image);
            const rules = getTemplateRules(archetype);
            let m: SlideModel = {
                id,
                slide_type: archetype,
                title: s.title,
                bullets: baseBullets,
                image_url: image,
                section_id: undefined,
                objective_links: [],
                trainer_notes: null,
            };
            m = normalizeSlide(m, rules);
            const note = findMatchingScript(scripts, s.title);
            if (note) m.trainer_notes = note;
            const valid = validateSlide(m, rules);
            if (!valid) {
                const fallbackRules = getTemplateRules(SlideArchetype.Explainer);
                m.slide_type = SlideArchetype.Explainer;
                m = normalizeSlide(m, fallbackRules);
            }
            models.push(m);
        });
    }
    return models;
};

const renderSlideModels = async (pptx: PptxGenJS, course: Course, models: SlideModel[]): Promise<void> => {
    for (const m of models) {
        const slide = pptx.addSlide();
        const bulletsText = (m.bullets || []).join('\n');
        switch (m.slide_type) {
            case SlideArchetype.ImageText:
                slide.addText(m.title || '', { x: 0.5, y: 0.5, w: 5.5, h: 0.8, fontSize: 26, bold: true, color: '1F2937' });
                if (bulletsText) {
                    slide.addText(bulletsText, { x: 0.5, y: 1.4, w: 5.5, h: 4.8, fontSize: 18, bullet: true, color: '374151', lineSpacing: 28 });
                }
                try {
                    if (m.image_url) {
                        let dataUrl: string | null = null;
                        if (!m.image_url.startsWith('data:') && m.image_url.startsWith('http')) {
                            dataUrl = await fetchToDataUrl(m.image_url);
                        }
                        const isData = m.image_url.startsWith('data:') || !!dataUrl;
                        const box = { x: 6.1, y: 0.7, w: 3.4, h: 5.0 };
                        const pad = 0.15;
                        const dims = await getImageDims(dataUrl || m.image_url);
                        const fit = fitContain(box.w - pad * 2, box.h - pad * 2, dims.w, dims.h);
                        const xPos = box.x + pad + ((box.w - pad * 2) - fit.w) / 2;
                        const yPos = box.y + pad + ((box.h - pad * 2) - fit.h) / 2;
                        const opts: PptxGenJS.ImageProps = isData
                            ? { data: dataUrl || m.image_url, x: xPos, y: yPos, w: fit.w, h: fit.h }
                            : { path: m.image_url, x: xPos, y: yPos, w: fit.w, h: fit.h };
                        slide.addImage(opts);
                    }
                } catch (e) {
                    console.warn('Failed to add image in V2 renderer:', e);
                }
                break;
            case SlideArchetype.Quote:
                slide.addText(m.title || '', { x: 0.8, y: 1.2, w: 8.4, h: 3.2, fontSize: 32, italic: true, color: '111827', align: 'center' });
                break;
            case SlideArchetype.Exercise:
                slide.addText('', { x: 0, y: 0, w: 10, h: 0.9, fill: { color: 'ECFDF5' } });
                slide.addText('Exercițiu', { x: 0.5, y: 0.2, w: 9, h: 0.5, fontSize: 18, bold: true, color: '065F46' });
                slide.addText(m.title || '', { x: 0.5, y: 0.9, w: 9, h: 0.8, fontSize: 26, bold: true, color: '1F2937' });
                if (bulletsText) {
                    slide.addText(bulletsText, { x: 0.5, y: 1.8, w: 9, h: 4.8, fontSize: 18, bullet: true, color: '374151', lineSpacing: 28 });
                }
                break;
            case SlideArchetype.CaseStudy:
                slide.addText('', { x: 0, y: 0, w: 10, h: 0.9, fill: { color: 'DBEAFE' } });
                slide.addText('Studiu de caz', { x: 0.5, y: 0.2, w: 9, h: 0.5, fontSize: 18, bold: true, color: '1E40AF' });
                slide.addText(m.title || '', { x: 0.5, y: 0.9, w: 9, h: 0.8, fontSize: 26, bold: true, color: '1F2937' });
                if (bulletsText) {
                    slide.addText(bulletsText, { x: 0.5, y: 1.8, w: 9, h: 4.8, fontSize: 18, bullet: true, color: '374151', lineSpacing: 28 });
                }
                break;
            case SlideArchetype.Summary:
            case SlideArchetype.Explainer:
            default:
                slide.addText(m.title || '', { x: 0.5, y: 0.7, w: 9, h: 0.8, fontSize: 28, bold: true, color: '1F2937' });
                if (bulletsText) {
                    slide.addText(bulletsText, { x: 0.5, y: 1.7, w: 9, h: 4.8, fontSize: 18, bullet: true, color: '374151', lineSpacing: 28 });
                }
                break;
        }
        if (m.trainer_notes) {
            slide.addNotes(m.trainer_notes);
        }
        slide.addText(`${course.title}`, { x: 0.5, y: 6.8, w: 9, h: 0.3, fontSize: 10, color: '9CA3AF', align: 'right' });
    }
};

const buildSlideModelsFromContent = (markdown: string, titleKey: string, scripts: Record<string, string>): SlideModel[] => {
    const models: SlideModel[] = [];
    const sections = parseContentSections(markdown);
    sections.forEach((s, idx) => {
        const id = `${titleKey}_sec_${idx + 1}`;
        const image = s.images[0]?.url || null;
        const archetype = chooseArchetypeFor(titleKey, s.title, image);
        const rules = getTemplateRules(archetype);
        let m: SlideModel = {
            id,
            slide_type: archetype,
            title: s.title,
            bullets: s.bulletPoints.length > 0 ? s.bulletPoints : deriveBulletsFromBody(s.bodyText || ''),
            image_url: image,
            section_id: undefined,
            objective_links: [],
            trainer_notes: null,
        };
        m = normalizeSlide(m, rules);
        const note = findMatchingScript(scripts, s.title);
        if (note) m.trainer_notes = note;
        const valid = validateSlide(m, rules);
        if (!valid) {
            const fallbackRules = getTemplateRules(SlideArchetype.Explainer);
            m.slide_type = SlideArchetype.Explainer;
            m = normalizeSlide(m, fallbackRules);
        }
        models.push(m);
    });
    return models;
};

const exportCourseAsPptxV2 = async (course: Course): Promise<void> => {
    const pptx = new PptxGenJS();
    pptx.layout = 'LAYOUT_16x9';
    addTitleSlide(pptx, course);
    const slidesStep = findStepByKey(course, 'course.livrables.slides');
    const videoScriptStep = findStepByKey(course, 'video_scripts');
    const scripts = videoScriptStep ? parseVideoScripts(videoScriptStep.content) : {};
    if (slidesStep && slidesStep.content) {
        const contentWithPublic = await replaceBlobUrlsWithPublic(slidesStep.content, course.user_id, course.id);
        const contentAllPublic = await ensurePublicExternalImages(contentWithPublic, course.user_id, course.id);
        let models = buildSlideModelsFromContent(contentAllPublic, slidesStep.title_key, scripts);
        models = linkSlideModelsToBlueprint(course, models);
        await renderSlideModels(pptx, course, models);
    } else {
        const structureStep = findStepByKey(course, 'structure');
        addAgendaSlide(pptx, course, structureStep, videoScriptStep);
        let models = buildSlideModelsFromCourse(course, scripts);
        models = linkSlideModelsToBlueprint(course, models);
        await renderSlideModels(pptx, course, models);
        addSummarySlide(pptx);
    }
    const fileName = `${course.title.replace(/[^a-z0-9]/gi, '_')}.pptx`;
    await pptx.writeFile({ fileName });
};

const TEMPLATE_RULES: Record<SlideArchetype, SlideRules> = {
    [SlideArchetype.Title]: { maxTitleChars: 60 },
    [SlideArchetype.Explainer]: { maxTitleChars: 60, maxBullets: 5, maxBulletLength: 110 },
    [SlideArchetype.ImageText]: { maxTitleChars: 60, maxBullets: 4, maxBulletLength: 100, requiresImage: true },
    [SlideArchetype.Quote]: { maxTitleChars: 120 },
    [SlideArchetype.Agenda]: { maxBullets: 8, maxBulletLength: 80 },
    [SlideArchetype.Exercise]: { maxTitleChars: 80, maxBullets: 6, maxBulletLength: 120 },
    [SlideArchetype.CaseStudy]: { maxTitleChars: 80, maxBullets: 5, maxBulletLength: 120 },
    [SlideArchetype.Summary]: { maxBullets: 5, maxBulletLength: 80 },
};

export const getTemplateRules = (a: SlideArchetype): SlideRules => TEMPLATE_RULES[a] || { maxTitleChars: 60 };

const trimTo = (s: string, n: number): string => (s.length > n ? (s.slice(0, Math.max(0, n - 3)) + '…') : s);

export const normalizeSlide = (m: SlideModel, r: SlideRules): SlideModel => {
    const title = m.title ? (r.maxTitleChars ? trimTo(m.title, r.maxTitleChars) : m.title) : m.title;
    const maxB = typeof r.maxBullets === 'number' ? r.maxBullets : undefined;
    const clipBullets = (m.bullets || []).slice(0, maxB || (m.bullets || []).length).map(b => {
        const lim = r.maxBulletLength || 9999;
        return trimTo(b, lim);
    });
    const image = r.requiresImage ? (m.image_url || null) : (m.image_url || null);
    return { ...m, title, bullets: clipBullets, image_url: image };
};

export const validateSlide = (m: SlideModel, r: SlideRules): boolean => {
    if (r.maxTitleChars && (m.title || '').length > r.maxTitleChars) return false;
    if (r.maxBullets && (m.bullets || []).length > r.maxBullets) return false;
    const maxLen = r.maxBulletLength ?? null;
    if (maxLen !== null && (m.bullets || []).some(b => b.length > maxLen)) return false;
    if (r.requiresImage && !m.image_url) return false;
    const density = ((m.title || '').length) + (m.bullets || []).reduce((acc, b) => acc + b.length, 0);
    if (density > 1200) return false;
    return true;
};

export const chooseArchetypeFor = (titleKey: string, sectionTitle: string, imageUrl: string | null): SlideArchetype => {
    const tk = titleKey.toLowerCase();
    const st = sectionTitle.toLowerCase();
    if (tk.includes('exercise') || st.includes('exerci')) return SlideArchetype.Exercise;
    if (tk.includes('case') || st.includes('studiu')) return SlideArchetype.CaseStudy;
    if (tk.includes('summary') || tk.includes('recap') || st.includes('rezumat')) return SlideArchetype.Summary;
    if (tk.includes('quote') || st.includes('citat')) return SlideArchetype.Quote;
    if (imageUrl) return SlideArchetype.ImageText;
    return SlideArchetype.Explainer;
};

// ============================================================================
// LEGACY EXPORTS
// ============================================================================

const normalizeMarkdownImages = (md: string): string => md.replace(/!\[([^\]]*)\]\s*\n\s*\(([^)]+)\)/g, '![$1]($2)');

const base64ToUint8Array = (base64: string): Uint8Array => {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
    return bytes;
};

const fetchImageBytes = async (url: string): Promise<Uint8Array | null> => {
    try {
        if (url.startsWith('data:')) {
            const payload = url.split('base64,')[1] || '';
            if (!payload) return null;
            return base64ToUint8Array(payload);
        }
        const res = await fetch(url);
        if (!res.ok) return null;
        const buf = await res.arrayBuffer();
        return new Uint8Array(buf);
    } catch {
        return null;
    }
};

const parseTextToRuns = (text: string): TextRun[] => {
    const runs: TextRun[] = [];
    const parts = text.split(/(\*\*.*?\*\*)/g);
    parts.forEach(part => {
        if (part.startsWith('**') && part.endsWith('**')) {
            runs.push(new TextRun({ text: part.slice(2, -2), bold: true }));
        } else if (part) {
            runs.push(new TextRun(part));
        }
    });
    return runs;
};

const createDocxTable = (lines: string[]): Table | null => {
    try {
        const rows = lines.map(line => {
            const content = line.trim().replace(/^\|/, '').replace(/\|$/, '');
            return content.split('|').map(c => c.trim());
        });

        if (rows.length < 2) return null;

        const headers = rows[0];
        const dataRows = rows.slice(2); // Skip separator row

        const tableRows: TableRow[] = [];

        // Header
        tableRows.push(new TableRow({
            tableHeader: true,
            children: headers.map(h => new TableCell({
                children: [new Paragraph({
                    children: [new TextRun({ text: h, bold: true })],
                    alignment: AlignmentType.CENTER
                })],
                shading: { fill: "F3F4F6" },
                verticalAlign: "center",
                borders: {
                    top: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
                    bottom: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
                    left: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
                    right: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
                }
            }))
        }));

        // Body
        dataRows.forEach(row => {
            const cells = row.map(cellText => new TableCell({
                children: [new Paragraph({ children: parseTextToRuns(cellText) })],
                borders: {
                    top: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                    bottom: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                    left: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                    right: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                }
            }));
            tableRows.push(new TableRow({ children: cells }));
        });

        return new Table({
            rows: tableRows,
            width: { size: 100, type: WidthType.PERCENTAGE },
        });
    } catch (e) {
        console.warn('Failed to parse table:', e);
        return null;
    }
};

const buildDocxParagraphs = async (content: string): Promise<(Paragraph | Table)[]> => {
    const children: (Paragraph | Table)[] = [];
    const lines = normalizeMarkdownImages(content).split('\n');
    const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/;

    let i = 0;
    while (i < lines.length) {
        const line = lines[i];
        const trimmed = line.trim();

        // Detect Table
        if (trimmed.startsWith('|') && i + 1 < lines.length) {
            const nextLine = lines[i + 1].trim();
            if (nextLine.startsWith('|') && nextLine.includes('---')) {
                const tableLines: string[] = [];
                while (i < lines.length && lines[i].trim().startsWith('|')) {
                    tableLines.push(lines[i]);
                    i++;
                }
                const table = createDocxTable(tableLines);
                if (table) {
                    children.push(table);
                } else {
                    tableLines.forEach(l => children.push(new Paragraph({ text: l })));
                }
                continue;
            }
        }

        const match = line.match(imageRegex);
        if (match) {
            const alt = match[1] || '';
            const url = match[2];
            const bytes = await fetchImageBytes(url);
            if (bytes) {
                children.push(new Paragraph({ children: [new ImageRun({ data: bytes, transformation: { width: 480, height: 360 } })] }));
            } else {
                children.push(new Paragraph({ children: [new TextRun(`Image: ${alt}`)] }));
            }
            i++;
            continue;
        }

        if (line.startsWith('# ')) {
            children.push(new Paragraph({ text: line.substring(2), heading: HeadingLevel.HEADING_1, alignment: AlignmentType.CENTER }));
        } else if (line.startsWith('## ')) {
            children.push(new Paragraph({ text: line.substring(3), heading: HeadingLevel.HEADING_2 }));
        } else if (line.startsWith('### ')) {
            children.push(new Paragraph({ text: line.substring(4), heading: HeadingLevel.HEADING_3 }));
        } else if (line.startsWith('* ') || line.startsWith('- ')) {
            children.push(new Paragraph({ text: line.substring(2), bullet: { level: 0 } }));
        } else if (trimmed === '') {
            children.push(new Paragraph({ text: '' }));
        } else {
            children.push(new Paragraph({ children: parseTextToRuns(line) }));
        }
        i++;
    }
    return children;
};

const createDocx = async (step: CourseStep, courseTitle: string, stepTitle: string): Promise<Blob> => {
    const pre = normalizeExternalImageLinks(step.content);
    const withPublic = await replaceBlobUrlsWithPublic(pre, step.user_id || null, step.course_id || null);
    const children = await buildDocxParagraphs(withPublic);
    const doc = new Document({
        sections: [{
            headers: {
                default: new Header({
                    children: [
                        new Paragraph({
                            children: [
                                new TextRun({ text: `${courseTitle} - ${stepTitle}`, size: 18, color: "888888" }),
                            ],
                            alignment: AlignmentType.RIGHT,
                        }),
                    ]
                }),
            },
            children,
        }],
    });
    return Packer.toBlob(doc);
};

export const exportCourseAsZip = async (course: Course, t: (key: string) => string): Promise<void> => {
    console.log('[Export] Starting zip export for:', course.title);
    const zip = new JSZip();

    for (const step of course.steps || []) {
        const stepTitle = t(step.title_key).replace(/^\d+\.\s*/, '');
        const blob = await createDocx(step, course.title, stepTitle);
        const fileName = `${stepTitle}.docx`;
        zip.file(fileName, blob);
    }

    // Generate ZIP with proper MIME type
    const zipBlob = await zip.generateAsync({
        type: 'blob',
        mimeType: 'application/zip'
    });

    const safeCourseTitle = course.title.replace(/[^a-z0-9]/gi, '_');
    const finalFileName = `course_${safeCourseTitle}.zip`;

    console.log('[Export] Zip generated, triggering download for:', finalFileName);

    // Trigger download using standard approach
    const url = URL.createObjectURL(zipBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = finalFileName;
    link.style.display = 'none';
    document.body.appendChild(link);
    link.click();

    // Cleanup
    setTimeout(() => {
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }, 100);
};

// Re-export PDF export function
export { exportCourseAsPdf };
