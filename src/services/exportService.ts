import PptxGenJS from 'pptxgenjs';
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, Header, ImageRun } from 'docx';
import JSZip from 'jszip';

import { Course, CourseStep, SlideModel, SlideArchetype, SlideRules } from '../types';
import { replaceBlobUrlsWithPublic } from './imageService';
import { isEnabled } from '../config/featureFlags';

// ============================================================================
// TYPES & INTERFACES
// ============================================================================

interface ContentSection {
    title: string;
    bulletPoints: string[];
    images: { url: string; alt: string }[];
    rawContent: string;
}

// ============================================================================
// HELPER FUNCTIONS - SLIDE GENERATORS
// ============================================================================

const addTitleSlide = (pptx: PptxGenJS, course: Course): void => {
    const slide = pptx.addSlide();
    slide.background = { color: '1E3A8A' };

    slide.addText(course.title, {
        x: 0.5, y: 2, w: '90%', h: 1.5,
        fontSize: 44, bold: true, color: 'FFFFFF',
        align: 'center'
    });

    slide.addText(course.subject, {
        x: 0.5, y: 3.5, w: '90%', h: 0.8,
        fontSize: 24, color: 'E5E7EB',
        align: 'center'
    });

    slide.addText('Generated by AI Course Co-Pilot', {
        x: 0.5, y: 6.5, w: '90%', h: 0.3,
        fontSize: 12, color: '9CA3AF',
        align: 'center', italic: true
    });
};

const addAgendaSlide = (
    pptx: PptxGenJS,
    course: Course,
    structureStep: CourseStep | null,
    videoScriptStep: CourseStep | null
): void => {
    const slide = pptx.addSlide();

    slide.addText('Structura Cursului', {
        x: 0.5, y: 0.5, w: '90%', h: 0.8,
        fontSize: 32, bold: true, color: '1F2937'
    });

    const modules = structureStep
        ? parseModulesFromStructure(structureStep.content)
        : generateModulesFromSteps(course.steps || []);

    slide.addText(modules, {
        x: 0.5, y: 1.5, w: '90%', h: 5,
        fontSize: 18, bullet: true, color: '374151',
        lineSpacing: 28
    });

    if (videoScriptStep) {
        const introScript = extractIntroScript(videoScriptStep.content);
        if (introScript) {
            slide.addNotes(introScript);
        }
    }
};

const addContentSlides = async (
    pptx: PptxGenJS,
    step: CourseStep,
    course: Course,
    videoScripts: Record<string, string>
): Promise<void> => {
    const sections = parseContentSections(step.content);

    for (const section of sections) {
        const slide = pptx.addSlide();

        slide.addText(section.title, {
            x: 0.5, y: 0.5, w: '90%', h: 0.8,
            fontSize: 28, bold: true, color: '1F2937'
        });

        if (section.bulletPoints.length > 0) {
            const bulletText = section.bulletPoints.join('\n');
            slide.addText(bulletText, {
                x: 0.5, y: 1.5, w: '90%', h: 4,
                fontSize: 18, bullet: true, color: '374151',
                lineSpacing: 28
            });
        }

        if (section.images.length > 0) {
            const yPos = 5.5;
            for (const img of section.images.slice(0, 1)) {
                try {
                    if (img.url.startsWith('data:') || img.url.startsWith('http')) {
                        slide.addImage({
                            data: img.url,
                            x: 0.5, y: yPos, w: 8, h: 1.5
                        });
                    }
                } catch (e) {
                    console.warn('Failed to add image:', e);
                }
            }
        }

        const matchingScript = findMatchingScript(videoScripts, section.title);
        if (matchingScript) {
            slide.addNotes(matchingScript);
        }

        slide.addText(`${course.title} | ${new Date().toLocaleDateString()}`, {
            x: 0.5, y: 6.8, w: '90%', h: 0.3,
            fontSize: 10, color: '9CA3AF', align: 'right'
        });
    }
};

const addSummarySlide = (pptx: PptxGenJS): void => {
    const slide = pptx.addSlide();
    slide.background = { color: 'F3F4F6' };

    slide.addText('Recapitulare', {
        x: 0.5, y: 1.5, w: '90%', h: 1,
        fontSize: 36, bold: true, color: '1F2937',
        align: 'center'
    });

    const summaryText = [
        'Mulțumim pentru participare!',
        'Continuați cu proiectele practice',
        'Descărcați cheat sheet-ul pentru referință rapidă',
        'Aplicați tehnicile învățate în următoarele 48h'
    ].join('\n');

    slide.addText(summaryText, {
        x: 0.5, y: 3, w: '90%', h: 3,
        fontSize: 20, bullet: true, color: '374151',
        align: 'center', lineSpacing: 32
    });
};

// ============================================================================
// PARSER FUNCTIONS
// ============================================================================

const parseContentSections = (markdown: string): ContentSection[] => {
    const sections: ContentSection[] = [];
    const lines = markdown.split('\n');
    let currentTitle: string | null = null;
    let currentBullets: string[] = [];
    let currentImages: { url: string; alt: string }[] = [];
    const flush = () => {
        if (!currentTitle) return;
        sections.push({ title: currentTitle, bulletPoints: currentBullets, images: currentImages, rawContent: '' });
        currentTitle = null;
        currentBullets = [];
        currentImages = [];
    };
    for (const raw of lines) {
        const line = raw.trim();
        const isH2 = line.startsWith('## ');
        const isBoldTitle = line.startsWith('**') && line.endsWith('**') && line.length > 4;
        if (isH2 || isBoldTitle) {
            flush();
            let t = isH2 ? line.substring(3) : line.substring(2, line.length - 2);
            t = t.replace(/^Slide\s*\d+\s*:\s*/i, '').trim();
            currentTitle = t;
            continue;
        }
        if (line.startsWith('* ') || line.startsWith('- ')) {
            let b = line.substring(2).trim();
            b = b.replace(/\*\*|__|`/g, '').trim();
            if (b.length > 0 && b.length < 150) currentBullets.push(b);
            continue;
        }
        const imgMatch = line.match(/!\[([^\]]*)\]\(([^)]+)\)/);
        if (imgMatch) {
            currentImages.push({ alt: imgMatch[1], url: imgMatch[2] });
            continue;
        }
    }
    flush();
    return sections.filter(s => !!s.title);
};

const parseVideoScripts = (markdown: string): Record<string, string> => {
    const scripts: Record<string, string> = {};
    const lessons = markdown.split(/\n(?=## )/);

    for (const lesson of lessons) {
        const titleMatch = lesson.match(/^##\s*(.+)/m);
        if (!titleMatch) continue;

        const title = titleMatch[1].trim();
        const audioMatches = lesson.matchAll(/\[AUDIO\]\s*(.+?)(?=\[VISUAL\]|\n\n|$)/gs);
        const audioContent = Array.from(audioMatches)
            .map(m => m[1].trim())
            .join('\n\n');

        if (audioContent) {
            scripts[title] = audioContent;
        }
    }

    return scripts;
};

const findMatchingScript = (
    scripts: Record<string, string>,
    slideTitle: string
): string | null => {
    if (scripts[slideTitle]) {
        return scripts[slideTitle];
    }

    const keywords = slideTitle.toLowerCase().split(' ').filter(w => w.length > 3);
    for (const [scriptTitle, content] of Object.entries(scripts)) {
        const matches = keywords.filter(kw =>
            scriptTitle.toLowerCase().includes(kw)
        );
        if (matches.length >= 2) {
            return content;
        }
    }

    return null;
};

const extractIntroScript = (markdown: string): string => {
    const introMatch = markdown.match(/\[AUDIO\]\s*(.+?)(?=\[VISUAL\]|\n##|$)/s);
    return introMatch ? introMatch[1].trim() : '';
};

const parseModulesFromStructure = (markdown: string): string => {
    const lines = markdown.split('\n');
    const modules: string[] = [];

    for (const line of lines) {
        if (line.match(/^(Modul|Module)\s+\d+:/i)) {
            modules.push(line.trim());
        } else if (line.match(/^\s*[\*\-]\s+\*\*Lecția/i)) {
            modules.push('  ' + line.trim().replace(/^\s*[\*\-]\s+/, ''));
        }
    }

    return modules.length > 0 ? modules.join('\n') : 'Structura cursului va fi detaliată în lecțiile următoare.';
};

const generateModulesFromSteps = (steps: CourseStep[]): string => {
    return steps
        .filter(s => !shouldExcludeFromSlides(s))
        .map((s, i) => `${i + 1}. ${s.title_key}`)
        .join('\n');
};

const shouldExcludeFromSlides = (step: CourseStep): boolean => {
    const excludedKeys = ['structure', 'video_scripts', 'tests', 'cheat_sheets'];
    return excludedKeys.some(key => step.title_key.toLowerCase().includes(key));
};

const findStepByKey = (course: Course, keyPattern: string): CourseStep | null => {
    return course.steps?.find(s =>
        s.title_key.toLowerCase().includes(keyPattern.toLowerCase())
    ) || null;
};

// ============================================================================
// MAIN EXPORT FUNCTIONS
// ============================================================================

export const exportCourseAsPptx = async (course: Course): Promise<void> => {
    if (isEnabled('newPptxExporter')) {
        await exportCourseAsPptxV2(course);
        return;
    }
    const pptx = new PptxGenJS();
    pptx.layout = 'LAYOUT_16x9';

    addTitleSlide(pptx, course);

    const structureStep = findStepByKey(course, 'structure');
    const videoScriptStep = findStepByKey(course, 'video_scripts');
    addAgendaSlide(pptx, course, structureStep, videoScriptStep);

    const videoScripts = videoScriptStep
        ? parseVideoScripts(videoScriptStep.content)
        : {};

    for (const step of course.steps || []) {
        if (!shouldExcludeFromSlides(step) && step.content) {
            await addContentSlides(pptx, step, course, videoScripts);
        }
    }

    addSummarySlide(pptx);

    const fileName = `${course.title.replace(/[^a-z0-9]/gi, '_')}.pptx`;
    await pptx.writeFile({ fileName });
};

// V2 exporter: builds SlideModel IR and renders archetypes deterministically
const buildSlideModelsFromCourse = (course: Course, scripts: Record<string, string>): SlideModel[] => {
    const models: SlideModel[] = [];
    const steps = course.steps || [];
    for (const step of steps) {
        if (shouldExcludeFromSlides(step) || !step.content) continue;
        const sections = parseContentSections(step.content);
        sections.forEach((s, idx) => {
            const id = `${step.id}_sec_${idx + 1}`;
            const baseBullets = s.bulletPoints;
            const image = s.images[0]?.url || null;
            const archetype = chooseArchetypeFor(step.title_key, s.title, image);
            const rules = getTemplateRules(archetype);
            let m: SlideModel = {
                id,
                slide_type: archetype,
                title: s.title,
                bullets: baseBullets,
                image_url: image,
                section_id: undefined,
                objective_links: [],
                trainer_notes: null,
            };
            m = normalizeSlide(m, rules);
            const note = findMatchingScript(scripts, s.title);
            if (note) m.trainer_notes = note;
            const valid = validateSlide(m, rules);
            if (!valid) {
                const fallbackRules = getTemplateRules(SlideArchetype.Explainer);
                m.slide_type = SlideArchetype.Explainer;
                m = normalizeSlide(m, fallbackRules);
            }
            models.push(m);
        });
    }
    return models;
};

const renderSlideModels = (pptx: PptxGenJS, course: Course, models: SlideModel[]): void => {
    models.forEach(m => {
        const slide = pptx.addSlide();
        const bulletsText = (m.bullets || []).join('\n');
        switch (m.slide_type) {
            case SlideArchetype.ImageText:
                slide.addText(m.title || '', { x: 0.5, y: 0.5, w: 5.5, h: 0.8, fontSize: 26, bold: true, color: '1F2937' });
                if (bulletsText) {
                    slide.addText(bulletsText, { x: 0.5, y: 1.4, w: 5.5, h: 4.8, fontSize: 18, bullet: true, color: '374151', lineSpacing: 28 });
                }
                try {
                    if (m.image_url) slide.addImage({ data: m.image_url, x: 6.2, y: 0.8, w: 3.2, h: 4.8 });
                } catch (e) {
                    console.warn('Failed to add image in V2 renderer:', e);
                }
                break;
            case SlideArchetype.Quote:
                slide.addText(m.title || '', { x: 0.8, y: 1.2, w: 8.4, h: 3.2, fontSize: 32, italic: true, color: '111827', align: 'center' });
                break;
            case SlideArchetype.Exercise:
                slide.addText('', { x: 0, y: 0, w: 10, h: 0.9, fill: { color: 'ECFDF5' } });
                slide.addText('Exercițiu', { x: 0.5, y: 0.2, w: 9, h: 0.5, fontSize: 18, bold: true, color: '065F46' });
                slide.addText(m.title || '', { x: 0.5, y: 0.9, w: 9, h: 0.8, fontSize: 26, bold: true, color: '1F2937' });
                if (bulletsText) {
                    slide.addText(bulletsText, { x: 0.5, y: 1.8, w: 9, h: 4.8, fontSize: 18, bullet: true, color: '374151', lineSpacing: 28 });
                }
                break;
            case SlideArchetype.CaseStudy:
                slide.addText('', { x: 0, y: 0, w: 10, h: 0.9, fill: { color: 'DBEAFE' } });
                slide.addText('Studiu de caz', { x: 0.5, y: 0.2, w: 9, h: 0.5, fontSize: 18, bold: true, color: '1E40AF' });
                slide.addText(m.title || '', { x: 0.5, y: 0.9, w: 9, h: 0.8, fontSize: 26, bold: true, color: '1F2937' });
                if (bulletsText) {
                    slide.addText(bulletsText, { x: 0.5, y: 1.8, w: 9, h: 4.8, fontSize: 18, bullet: true, color: '374151', lineSpacing: 28 });
                }
                break;
            case SlideArchetype.Summary:
            case SlideArchetype.Explainer:
            default:
                slide.addText(m.title || '', { x: 0.5, y: 0.7, w: 9, h: 0.8, fontSize: 28, bold: true, color: '1F2937' });
                if (bulletsText) {
                    slide.addText(bulletsText, { x: 0.5, y: 1.7, w: 9, h: 4.8, fontSize: 18, bullet: true, color: '374151', lineSpacing: 28 });
                }
                break;
        }
        if (m.trainer_notes) {
            slide.addNotes(m.trainer_notes);
        }
        slide.addText(`${course.title}`, { x: 0.5, y: 6.8, w: 9, h: 0.3, fontSize: 10, color: '9CA3AF', align: 'right' });
    });
};

const buildSlideModelsFromContent = (markdown: string, titleKey: string, scripts: Record<string, string>): SlideModel[] => {
    const models: SlideModel[] = [];
    const sections = parseContentSections(markdown);
    sections.forEach((s, idx) => {
        const id = `${titleKey}_sec_${idx + 1}`;
        const image = s.images[0]?.url || null;
        const archetype = chooseArchetypeFor(titleKey, s.title, image);
        const rules = getTemplateRules(archetype);
        let m: SlideModel = {
            id,
            slide_type: archetype,
            title: s.title,
            bullets: s.bulletPoints,
            image_url: image,
            section_id: undefined,
            objective_links: [],
            trainer_notes: null,
        };
        m = normalizeSlide(m, rules);
        const note = findMatchingScript(scripts, s.title);
        if (note) m.trainer_notes = note;
        const valid = validateSlide(m, rules);
        if (!valid) {
            const fallbackRules = getTemplateRules(SlideArchetype.Explainer);
            m.slide_type = SlideArchetype.Explainer;
            m = normalizeSlide(m, fallbackRules);
        }
        models.push(m);
    });
    return models;
};

const exportCourseAsPptxV2 = async (course: Course): Promise<void> => {
    const pptx = new PptxGenJS();
    pptx.layout = 'LAYOUT_16x9';
    addTitleSlide(pptx, course);
    const slidesStep = findStepByKey(course, 'course.livrables.slides');
    const videoScriptStep = findStepByKey(course, 'video_scripts');
    const scripts = videoScriptStep ? parseVideoScripts(videoScriptStep.content) : {};
    if (slidesStep && slidesStep.content) {
        const contentWithPublic = await replaceBlobUrlsWithPublic(slidesStep.content, course.user_id, course.id);
        const models = buildSlideModelsFromContent(contentWithPublic, slidesStep.title_key, scripts);
        renderSlideModels(pptx, course, models);
    } else {
        const structureStep = findStepByKey(course, 'structure');
        addAgendaSlide(pptx, course, structureStep, videoScriptStep);
        const models = buildSlideModelsFromCourse(course, scripts);
        renderSlideModels(pptx, course, models);
        addSummarySlide(pptx);
    }
    const fileName = `${course.title.replace(/[^a-z0-9]/gi, '_')}.pptx`;
    await pptx.writeFile({ fileName });
};

const TEMPLATE_RULES: Record<SlideArchetype, SlideRules> = {
    [SlideArchetype.Title]: { maxTitleChars: 60 },
    [SlideArchetype.Explainer]: { maxTitleChars: 60, maxBullets: 5, maxBulletLength: 110 },
    [SlideArchetype.ImageText]: { maxTitleChars: 60, maxBullets: 4, maxBulletLength: 100, requiresImage: true },
    [SlideArchetype.Quote]: { maxTitleChars: 120 },
    [SlideArchetype.Agenda]: { maxBullets: 8, maxBulletLength: 80 },
    [SlideArchetype.Exercise]: { maxTitleChars: 80, maxBullets: 6, maxBulletLength: 120 },
    [SlideArchetype.CaseStudy]: { maxTitleChars: 80, maxBullets: 5, maxBulletLength: 120 },
    [SlideArchetype.Summary]: { maxBullets: 5, maxBulletLength: 80 },
};

const getTemplateRules = (a: SlideArchetype): SlideRules => TEMPLATE_RULES[a] || { maxTitleChars: 60 };

const trimTo = (s: string, n: number): string => (s.length > n ? (s.slice(0, Math.max(0, n - 3)) + '…') : s);

const normalizeSlide = (m: SlideModel, r: SlideRules): SlideModel => {
    const title = m.title ? (r.maxTitleChars ? trimTo(m.title, r.maxTitleChars) : m.title) : m.title;
    const maxB = typeof r.maxBullets === 'number' ? r.maxBullets : undefined;
    const clipBullets = (m.bullets || []).slice(0, maxB || (m.bullets || []).length).map(b => {
        const lim = r.maxBulletLength || 9999;
        return trimTo(b, lim);
    });
    const image = r.requiresImage ? (m.image_url || null) : (m.image_url || null);
    return { ...m, title, bullets: clipBullets, image_url: image };
};

const validateSlide = (m: SlideModel, r: SlideRules): boolean => {
    if (r.maxTitleChars && (m.title || '').length > r.maxTitleChars) return false;
    if (r.maxBullets && (m.bullets || []).length > r.maxBullets) return false;
    const maxLen = r.maxBulletLength ?? null;
    if (maxLen !== null && (m.bullets || []).some(b => b.length > maxLen)) return false;
    if (r.requiresImage && !m.image_url) return false;
    const density = ((m.title || '').length) + (m.bullets || []).reduce((acc, b) => acc + b.length, 0);
    if (density > 1200) return false;
    return true;
};

const chooseArchetypeFor = (titleKey: string, sectionTitle: string, imageUrl: string | null): SlideArchetype => {
    const tk = titleKey.toLowerCase();
    const st = sectionTitle.toLowerCase();
    if (tk.includes('exercise') || st.includes('exerci')) return SlideArchetype.Exercise;
    if (tk.includes('case') || st.includes('studiu')) return SlideArchetype.CaseStudy;
    if (tk.includes('summary') || tk.includes('recap') || st.includes('rezumat')) return SlideArchetype.Summary;
    if (tk.includes('quote') || st.includes('citat')) return SlideArchetype.Quote;
    if (imageUrl) return SlideArchetype.ImageText;
    return SlideArchetype.Explainer;
};

// ============================================================================
// LEGACY EXPORTS
// ============================================================================

const normalizeMarkdownImages = (md: string): string => md.replace(/!\[([^\]]*)\]\s*\n\s*\(([^)]+)\)/g, '![$1]($2)');

const base64ToUint8Array = (base64: string): Uint8Array => {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
    return bytes;
};

const fetchImageBytes = async (url: string): Promise<Uint8Array | null> => {
    try {
        if (url.startsWith('data:')) {
            const payload = url.split('base64,')[1] || '';
            if (!payload) return null;
            return base64ToUint8Array(payload);
        }
        const res = await fetch(url);
        if (!res.ok) return null;
        const buf = await res.arrayBuffer();
        return new Uint8Array(buf);
    } catch {
        return null;
    }
};

const buildDocxParagraphs = async (content: string): Promise<Paragraph[]> => {
    const paragraphs: Paragraph[] = [];
    const lines = normalizeMarkdownImages(content).split('\n');
    const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/;

    for (const line of lines) {
        const match = line.match(imageRegex);
        if (match) {
            const alt = match[1] || '';
            const url = match[2];
            const bytes = await fetchImageBytes(url);
            if (bytes) {
                paragraphs.push(new Paragraph({ children: [new ImageRun({ data: bytes, transformation: { width: 480, height: 360 } })] }));
            } else {
                paragraphs.push(new Paragraph({ children: [new TextRun(`Image: ${alt}`)] }));
            }
            continue;
        }

        if (line.startsWith('# ')) {
            paragraphs.push(new Paragraph({ text: line.substring(2), heading: HeadingLevel.HEADING_1, alignment: AlignmentType.CENTER }));
        } else if (line.startsWith('## ')) {
            paragraphs.push(new Paragraph({ text: line.substring(3), heading: HeadingLevel.HEADING_2 }));
        } else if (line.startsWith('### ')) {
            paragraphs.push(new Paragraph({ text: line.substring(4), heading: HeadingLevel.HEADING_3 }));
        } else if (line.startsWith('* ') || line.startsWith('- ')) {
            paragraphs.push(new Paragraph({ text: line.substring(2), bullet: { level: 0 } }));
        } else if (line.trim() === '') {
            paragraphs.push(new Paragraph({ text: '' }));
        } else {
            const runs: TextRun[] = [];
            const parts = line.split(/(\*\*.*?\*\*)/g);
            parts.forEach(part => {
                if (part.startsWith('**') && part.endsWith('**')) {
                    runs.push(new TextRun({ text: part.slice(2, -2), bold: true }));
                } else if (part) {
                    runs.push(new TextRun(part));
                }
            });
            paragraphs.push(new Paragraph({ children: runs }));
        }
    }
    return paragraphs;
};

const createDocx = async (step: CourseStep, courseTitle: string, stepTitle: string): Promise<Blob> => {
    const children = await buildDocxParagraphs(step.content);
    const doc = new Document({
        sections: [{
            headers: {
                default: new Header({
                    children: [
                        new Paragraph({
                            children: [
                                new TextRun({ text: `${courseTitle} - ${stepTitle}`, size: 18, color: "888888" }),
                            ],
                            alignment: AlignmentType.RIGHT,
                        }),
                    ]
                }),
            },
            children,
        }],
    });
    return Packer.toBlob(doc);
};

const triggerDownload = (blob: Blob, fileName: string): void => {
    console.log(`[Export] Triggering download for: ${fileName}, size=${blob.size}, type=${blob.type}`);
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = fileName;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
};

export const exportCourseAsZip = async (course: Course, t: (key: string) => string): Promise<void> => {
    console.log('[Export] Starting zip export for:', course.title);
    const zip = new JSZip();

    for (const step of course.steps || []) {
        const stepTitle = t(step.title_key).replace(/^\d+\.\s*/, '');
        const blob = await createDocx(step, course.title, stepTitle);
        const fileName = `${stepTitle}.docx`;
        zip.file(fileName, blob);
    }

    // Force application/octet-stream to prevent browser from trying to display it
    const zipBlob = await zip.generateAsync({
        type: 'blob',
        mimeType: 'application/octet-stream'
    });

    const safeCourseTitle = course.title.replace(/[^a-z0-9]/gi, '_');
    const finalFileName = `course_${safeCourseTitle}.zip`;

    console.log('[Export] Zip generated, triggering download for:', finalFileName);
    triggerDownload(zipBlob, finalFileName);
};
