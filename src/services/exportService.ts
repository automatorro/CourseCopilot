import PptxGenJS from 'pptxgenjs';
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, Header, ImageRun } from 'docx';
import JSZip from 'jszip';
import saveAs from 'file-saver';
import { Course, CourseStep } from '../types';

// ============================================================================
// TYPES & INTERFACES
// ============================================================================

interface ContentSection {
    title: string;
    bulletPoints: string[];
    images: { url: string; alt: string }[];
    rawContent: string;
}

// ============================================================================
// HELPER FUNCTIONS - SLIDE GENERATORS
// ============================================================================

const addTitleSlide = (pptx: PptxGenJS, course: Course): void => {
    const slide = pptx.addSlide();
    slide.background = { color: '1E3A8A' };

    slide.addText(course.title, {
        x: 0.5, y: 2, w: '90%', h: 1.5,
        fontSize: 44, bold: true, color: 'FFFFFF',
        align: 'center'
    });

    slide.addText(course.subject, {
        x: 0.5, y: 3.5, w: '90%', h: 0.8,
        fontSize: 24, color: 'E5E7EB',
        align: 'center'
    });

    slide.addText('Generated by AI Course Co-Pilot', {
        x: 0.5, y: 6.5, w: '90%', h: 0.3,
        fontSize: 12, color: '9CA3AF',
        align: 'center', italic: true
    });
};

const addAgendaSlide = (
    pptx: PptxGenJS,
    course: Course,
    structureStep: CourseStep | null,
    videoScriptStep: CourseStep | null
): void => {
    const slide = pptx.addSlide();

    slide.addText('Structura Cursului', {
        x: 0.5, y: 0.5, w: '90%', h: 0.8,
        fontSize: 32, bold: true, color: '1F2937'
    });

    const modules = structureStep
        ? parseModulesFromStructure(structureStep.content)
        : generateModulesFromSteps(course.steps || []);

    slide.addText(modules, {
        x: 0.5, y: 1.5, w: '90%', h: 5,
        fontSize: 18, bullet: true, color: '374151',
        lineSpacing: 28
    });

    if (videoScriptStep) {
        const introScript = extractIntroScript(videoScriptStep.content);
        if (introScript) {
            slide.addNotes(introScript);
        }
    }
};

const addContentSlides = async (
    pptx: PptxGenJS,
    step: CourseStep,
    course: Course,
    videoScripts: Record<string, string>
): Promise<void> => {
    const sections = parseContentSections(step.content);

    for (const section of sections) {
        const slide = pptx.addSlide();

        slide.addText(section.title, {
            x: 0.5, y: 0.5, w: '90%', h: 0.8,
            fontSize: 28, bold: true, color: '1F2937'
        });

        if (section.bulletPoints.length > 0) {
            const bulletText = section.bulletPoints.join('\n');
            slide.addText(bulletText, {
                x: 0.5, y: 1.5, w: '90%', h: 4,
                fontSize: 18, bullet: true, color: '374151',
                lineSpacing: 28
            });
        }

        if (section.images.length > 0) {
            let yPos = 5.5;
            for (const img of section.images.slice(0, 1)) {
                try {
                    if (img.url.startsWith('data:') || img.url.startsWith('http')) {
                        slide.addImage({
                            data: img.url,
                            x: 0.5, y: yPos, w: 8, h: 1.5
                        });
                    }
                } catch (e) {
                    console.warn('Failed to add image:', e);
                }
            }
        }

        const matchingScript = findMatchingScript(videoScripts, section.title);
        if (matchingScript) {
            slide.addNotes(matchingScript);
        }

        slide.addText(`${course.title} | ${new Date().toLocaleDateString()}`, {
            x: 0.5, y: 6.8, w: '90%', h: 0.3,
            fontSize: 10, color: '9CA3AF', align: 'right'
        });
    }
};

const addSummarySlide = (pptx: PptxGenJS): void => {
    const slide = pptx.addSlide();
    slide.background = { color: 'F3F4F6' };

    slide.addText('Recapitulare', {
        x: 0.5, y: 1.5, w: '90%', h: 1,
        fontSize: 36, bold: true, color: '1F2937',
        align: 'center'
    });

    const summaryText = [
        'Mulțumim pentru participare!',
        'Continuați cu proiectele practice',
        'Descărcați cheat sheet-ul pentru referință rapidă',
        'Aplicați tehnicile învățate în următoarele 48h'
    ].join('\n');

    slide.addText(summaryText, {
        x: 0.5, y: 3, w: '90%', h: 3,
        fontSize: 20, bullet: true, color: '374151',
        align: 'center', lineSpacing: 32
    });
};

// ============================================================================
// PARSER FUNCTIONS
// ============================================================================

const parseContentSections = (markdown: string): ContentSection[] => {
    const sections: ContentSection[] = [];
    const rawSections = markdown.split(/\n(?=## )/);

    for (const rawSection of rawSections) {
        const lines = rawSection.trim().split('\n');
        const titleLine = lines[0] || '';
        const title = titleLine.replace(/^##\s*/, '').trim();

        if (!title) continue;

        const bulletPoints: string[] = [];
        const images: { url: string; alt: string }[] = [];

        for (const line of lines.slice(1)) {
            if (line.match(/^[\*\-]\s+/)) {
                const bullet = line.replace(/^[\*\-]\s+/, '').trim();
                if (bullet.length > 0 && bullet.length < 150) {
                    bulletPoints.push(bullet);
                }
            }

            const imgMatch = line.match(/!\[([^\]]*)\]\(([^)]+)\)/);
            if (imgMatch) {
                images.push({ alt: imgMatch[1], url: imgMatch[2] });
            }
        }

        sections.push({
            title,
            bulletPoints,
            images,
            rawContent: rawSection
        });
    }

    return sections;
};

const parseVideoScripts = (markdown: string): Record<string, string> => {
    const scripts: Record<string, string> = {};
    const lessons = markdown.split(/\n(?=## )/);

    for (const lesson of lessons) {
        const titleMatch = lesson.match(/^##\s*(.+)/m);
        if (!titleMatch) continue;

        const title = titleMatch[1].trim();
        const audioMatches = lesson.matchAll(/\[AUDIO\]\s*(.+?)(?=\[VISUAL\]|\n\n|$)/gs);
        const audioContent = Array.from(audioMatches)
            .map(m => m[1].trim())
            .join('\n\n');

        if (audioContent) {
            scripts[title] = audioContent;
        }
    }

    return scripts;
};

const findMatchingScript = (
    scripts: Record<string, string>,
    slideTitle: string
): string | null => {
    if (scripts[slideTitle]) {
        return scripts[slideTitle];
    }

    const keywords = slideTitle.toLowerCase().split(' ').filter(w => w.length > 3);
    for (const [scriptTitle, content] of Object.entries(scripts)) {
        const matches = keywords.filter(kw =>
            scriptTitle.toLowerCase().includes(kw)
        );
        if (matches.length >= 2) {
            return content;
        }
    }

    return null;
};

const extractIntroScript = (markdown: string): string => {
    const introMatch = markdown.match(/\[AUDIO\]\s*(.+?)(?=\[VISUAL\]|\n##|$)/s);
    return introMatch ? introMatch[1].trim() : '';
};

const parseModulesFromStructure = (markdown: string): string => {
    const lines = markdown.split('\n');
    const modules: string[] = [];

    for (const line of lines) {
        if (line.match(/^(Modul|Module)\s+\d+:/i)) {
            modules.push(line.trim());
        } else if (line.match(/^\s*[\*\-]\s+\*\*Lecția/i)) {
            modules.push('  ' + line.trim().replace(/^\s*[\*\-]\s+/, ''));
        }
    }

    return modules.length > 0 ? modules.join('\n') : 'Structura cursului va fi detaliată în lecțiile următoare.';
};

const generateModulesFromSteps = (steps: CourseStep[]): string => {
    return steps
        .filter(s => !shouldExcludeFromSlides(s))
        .map((s, i) => `${i + 1}. ${s.title_key}`)
        .join('\n');
};

const shouldExcludeFromSlides = (step: CourseStep): boolean => {
    const excludedKeys = ['structure', 'video_scripts', 'tests', 'cheat_sheets'];
    return excludedKeys.some(key => step.title_key.toLowerCase().includes(key));
};

const findStepByKey = (course: Course, keyPattern: string): CourseStep | null => {
    return course.steps?.find(s =>
        s.title_key.toLowerCase().includes(keyPattern.toLowerCase())
    ) || null;
};

// ============================================================================
// MAIN EXPORT FUNCTIONS
// ============================================================================

export const exportCourseAsPptx = async (course: Course): Promise<void> => {
    const pptx = new PptxGenJS();
    pptx.layout = 'LAYOUT_16x9';

    addTitleSlide(pptx, course);

    const structureStep = findStepByKey(course, 'structure');
    const videoScriptStep = findStepByKey(course, 'video_scripts');
    addAgendaSlide(pptx, course, structureStep, videoScriptStep);

    const videoScripts = videoScriptStep
        ? parseVideoScripts(videoScriptStep.content)
        : {};

    for (const step of course.steps || []) {
        if (!shouldExcludeFromSlides(step) && step.content) {
            await addContentSlides(pptx, step, course, videoScripts);
        }
    }

    addSummarySlide(pptx);

    const fileName = `${course.title.replace(/[^a-z0-9]/gi, '_')}.pptx`;
    await pptx.writeFile({ fileName });
};

// ============================================================================
// LEGACY EXPORTS
// ============================================================================

const normalizeMarkdownImages = (md: string): string => md.replace(/!\[([^\]]*)\]\s*\n\s*\(([^)]+)\)/g, '![$1]($2)');

const base64ToUint8Array = (base64: string): Uint8Array => {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
    return bytes;
};

const fetchImageBytes = async (url: string): Promise<Uint8Array | null> => {
    try {
        if (url.startsWith('data:')) {
            const payload = url.split('base64,')[1] || '';
            if (!payload) return null;
            return base64ToUint8Array(payload);
        }
        const res = await fetch(url);
        if (!res.ok) return null;
        const buf = await res.arrayBuffer();
        return new Uint8Array(buf);
    } catch {
        return null;
    }
};

const buildDocxParagraphs = async (content: string): Promise<Paragraph[]> => {
    const paragraphs: Paragraph[] = [];
    const lines = normalizeMarkdownImages(content).split('\n');
    const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/;

    for (const line of lines) {
        const match = line.match(imageRegex);
        if (match) {
            const alt = match[1] || '';
            const url = match[2];
            const bytes = await fetchImageBytes(url);
            if (bytes) {
                paragraphs.push(new Paragraph({ children: [new ImageRun({ data: bytes, transformation: { width: 480, height: 360 } })] }));
            } else {
                paragraphs.push(new Paragraph({ children: [new TextRun(`Image: ${alt}`)] }));
            }
            continue;
        }

        if (line.startsWith('# ')) {
            paragraphs.push(new Paragraph({ text: line.substring(2), heading: HeadingLevel.HEADING_1, alignment: AlignmentType.CENTER }));
        } else if (line.startsWith('## ')) {
            paragraphs.push(new Paragraph({ text: line.substring(3), heading: HeadingLevel.HEADING_2 }));
        } else if (line.startsWith('### ')) {
            paragraphs.push(new Paragraph({ text: line.substring(4), heading: HeadingLevel.HEADING_3 }));
        } else if (line.startsWith('* ') || line.startsWith('- ')) {
            paragraphs.push(new Paragraph({ text: line.substring(2), bullet: { level: 0 } }));
        } else if (line.trim() === '') {
            paragraphs.push(new Paragraph({ text: '' }));
        } else {
            const runs: TextRun[] = [];
            const parts = line.split(/(\*\*.*?\*\*)/g);
            parts.forEach(part => {
                if (part.startsWith('**') && part.endsWith('**')) {
                    runs.push(new TextRun({ text: part.slice(2, -2), bold: true }));
                } else if (part) {
                    runs.push(new TextRun(part));
                }
            });
            paragraphs.push(new Paragraph({ children: runs }));
        }
    }
    return paragraphs;
};

const createDocx = async (step: CourseStep, courseTitle: string, stepTitle: string): Promise<Blob> => {
    const children = await buildDocxParagraphs(step.content);
    const doc = new Document({
        sections: [{
            headers: {
                default: new Header({
                    children: [
                        new Paragraph({
                            children: [
                                new TextRun({ text: `${courseTitle} - ${stepTitle}`, size: 18, color: "888888" }),
                            ],
                            alignment: AlignmentType.RIGHT,
                        }),
                    ]
                }),
            },
            children,
        }],
    });
    return Packer.toBlob(doc);
};

export const exportCourseAsZip = async (course: Course, t: (key: string) => string): Promise<void> => {
    const zip = new JSZip();

    for (const step of course.steps || []) {
        const stepTitle = t(step.title_key).replace(/^\d+\.\s*/, '');
        const blob = await createDocx(step, course.title, stepTitle);
        const fileName = `${stepTitle}.docx`;
        zip.file(fileName, blob);
    }

    const zipBlob = await zip.generateAsync({ type: 'blob' });
    const safeCourseTitle = course.title.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    saveAs(zipBlob, `course_${safeCourseTitle}.zip`);
};