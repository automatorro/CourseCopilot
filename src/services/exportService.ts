import PptxGenJS from 'pptxgenjs';
import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, Header, ImageRun, Table, TableRow, TableCell, WidthType, BorderStyle } from 'docx';
import JSZip from 'jszip';

import { Course, CourseStep, SlideModel, SlideArchetype, SlideRules } from '../types';
import { replaceBlobUrlsWithPublic, ensurePublicExternalImages } from './imageService';
// import { isEnabled } from '../config/featureFlags';
import { exportCourseAsPdf } from './pdfExporter';
import { SlideDesignJSON, getSmartFallbackDesign } from './presentationAiService';
import { searchImages } from './imageSearchService';
import { 
    renderHeroSlide, 
    renderSplitLeft, 
    renderSplitRight, 
    renderBigStat, 
    renderComparison, 
    renderQuotation, 
    renderTriad, 
    renderTimeline, 
    renderDefault,
    renderFullImage,
    renderGridCards,
    renderImageCenter,
    renderThreeColumns,
    renderSectionHeader,
    renderChecklist,
    renderDoDont,
    renderProcessSteps,
    renderKeyTakeaways,
    renderDataPoints,
    renderQuoteCenter,
    renderTableSimple,
    renderImageSidebar,
    renderAgendaCompact
} from '../lib/pptx/templates';

// ============================================================================
// TYPES & INTERFACES
// ============================================================================

interface ContentSection {
    title: string;
    bulletPoints: string[];
    images: { url: string; alt: string }[];
    rawContent: string;
    bodyText?: string;
    speakerNotes?: string;
    visualSearchTerm?: string;
}

const normalizeExternalImageLinks = (md: string): string => {
    try {
        let out = md;
        out = out.replace(/https?:\/\/unsplash\.com\/photos\/[\S)]+/gi, (m) => {
            const last = (m.split('/').pop() || '').split('?')[0];
            const id = last.includes('-') ? (last.split('-').pop() || last) : last;
            return `https://source.unsplash.com/${id}/1600x900`;
        });
        out = out.replace(/https?:\/\/(?:www\.)?pexels\.com\/photo\/[\w-]*?(\d+)\/?/gi, (_m: string, id: string) => {
            const safeId = String(id);
            return `https://images.pexels.com/photos/${safeId}/pexels-photo-${safeId}.jpeg?auto=compress&cs=tinysrgb&w=1600&h=900`;
        });
        out = out.replace(/https?:\/\/(?:www\.)?pixabay\.com\/photos\/[\w-]*?(\d+)\/?/gi, (_m: string, id: string) => {
            const safeId = String(id);
            return `https://cdn.pixabay.com/photo/${safeId}_1280.jpg`;
        });
        return out;
    } catch {
        return md;
    }
};

// ============================================================================
// HELPER FUNCTIONS - SLIDE GENERATORS
// ============================================================================

const addTitleSlide = (pptx: PptxGenJS, course: Course): void => {
    const slide = pptx.addSlide();
    slide.background = { color: '1E3A8A' };

    slide.addText(course.title, {
        x: 0.5, y: 2, w: '90%', h: 1.5,
        fontSize: 44, bold: true, color: 'FFFFFF',
        align: 'center'
    });

    slide.addText(course.subject, {
        x: 0.5, y: 3.5, w: '90%', h: 0.8,
        fontSize: 24, color: 'E5E7EB',
        align: 'center'
    });

    slide.addText('Generated by CourseCopilot', {
        x: 0.5, y: 6.5, w: '90%', h: 0.3,
        fontSize: 12, color: '9CA3AF',
        align: 'center', italic: true
    });
};

const addAgendaSlide = (
    pptx: PptxGenJS,
    course: Course,
    structureStep: CourseStep | null,
    videoScriptStep: CourseStep | null
): void => {
    const slide = pptx.addSlide();

    slide.addText('Structura Cursului', {
        x: 0.5, y: 0.5, w: '90%', h: 0.8,
        fontSize: 32, bold: true, color: '1F2937'
    });

    const modules = structureStep
        ? parseModulesFromStructure(structureStep.content)
        : generateModulesFromSteps(course.steps || []);

    slide.addText(modules, {
        x: 0.5, y: 1.5, w: '90%', h: 5,
        fontSize: 18, bullet: true, color: '374151',
        lineSpacing: 28
    });

    if (videoScriptStep) {
        const introScript = extractIntroScript(videoScriptStep.content);
        if (introScript) {
            slide.addNotes(introScript);
        }
    }
};

const addContentSlides = async (
    pptx: PptxGenJS,
    step: CourseStep,
    course: Course
): Promise<void> => {
    const pre = normalizeExternalImageLinks(step.content);
    const withPublic = await replaceBlobUrlsWithPublic(pre, course.user_id, course.id);
    const sections = parseContentSections(withPublic);

    for (const section of sections) {
        const slide = pptx.addSlide();

        // Slide Title
        slide.addText(section.title, {
            x: 0.5, y: 0.5, w: '90%', h: 0.8,
            fontSize: 28, bold: true, color: '1F2937'
        });

        // Content Bullets
        if (section.bulletPoints.length > 0) {
            const bulletText = section.bulletPoints.join('\n');
            slide.addText(bulletText, {
                x: 0.5, y: 1.5, w: '50%', h: 4, // Reduced width to make room for image
                fontSize: 18, bullet: true, color: '374151',
                lineSpacing: 28
            });
        } else if (section.bodyText) {
            slide.addText(section.bodyText, {
                x: 0.5, y: 1.5, w: '50%', h: 4.8,
                fontSize: 20, color: '374151',
                lineSpacing: 28
            });
        }

        // Handle Visuals (Placeholder or Real Image)
        const yPos = 1.5;
        // Check for Visual Search Term first (New Flow)
        if (section.visualSearchTerm) {
             // For now, use a safer placeholder logic
             // Extract just the first few meaningful words to avoid 503 errors from long queries
             const STOP = ['si','și','the','and','of','for','în','cu','la','din','pe','un','o','este','sunt','de','că','ca','的','和','是','在','de','e','para','em','uma','um','dos','das','ao','à'];
             const keywords = section.visualSearchTerm
                .toLowerCase()
                .split(/[\s,]+/)
                .filter(w => w.length > 3 && !STOP.includes(w))
                .slice(0, 4)
                .join(',');
             
             // Use a more reliable placeholder service if unsplash fails, or catch the error gracefully
             // We'll try source.unsplash.com but with very simple keywords
             const placeholderUrl = `https://source.unsplash.com/1600x900/?${keywords || 'business'}`;
             
             try {
                 // Try to fetch image first to handle CORS/Errors before passing to pptxgen
                 const dataUrl = await fetchToDataUrl(placeholderUrl);
                 if (dataUrl) {
                     slide.addImage({ 
                         data: dataUrl, 
                         x: 5.8, y: yPos, w: 4, h: 3 
                     });
                 } else {
                     // Fallback: Gray placeholder box if image fetch fails
                     slide.addText('Image Placeholder', { 
                         x: 5.8, y: yPos, w: 4, h: 3, 
                         fill: { color: 'F3F4F6' }, align: 'center', color: '9CA3AF' 
                     });
                 }
             } catch (e) {
                 console.warn('Failed to load visual placeholder:', e);
                 // Fallback: Gray placeholder box
                 slide.addText('Image Placeholder', { 
                     x: 5.8, y: yPos, w: 4, h: 3, 
                     fill: { color: 'F3F4F6' }, align: 'center', color: '9CA3AF' 
                 });
             }
        } 
        // Fallback to legacy embedded images or Smart Title Search
        else if (section.images.length > 0) {
            for (const img of section.images.slice(0, 1)) {
                try {
                    let dataUrl: string | null = null;
                    if (img.url.startsWith('http')) {
                        dataUrl = await fetchToDataUrl(img.url);
                    }
                    const isData = img.url.startsWith('data:') || !!dataUrl;
                    const opts: PptxGenJS.ImageProps = isData
                        ? { data: dataUrl || img.url, x: 5.8, y: yPos, w: 4, h: 3 }
                        : img.url.startsWith('http')
                            ? { path: img.url, x: 5.8, y: yPos, w: 4, h: 3 }
                            : null as unknown as PptxGenJS.ImageProps;
                    if (!opts) continue;
                    slide.addImage(opts);
                } catch (e) {
                    console.warn('Failed to add image:', e);
                }
            }
        } else {
             // NEW: Smart Title Search Fallback
             // If no visual tag AND no existing image, try searching Unsplash using the slide title
             // This ensures we don't have empty slides
             const keywords = section.title
                .split(/[\s,]+/)
                .filter(w => w.length > 3)
                .slice(0, 3)
                .join(',');
                
             if (keywords) {
                    const placeholderUrl = `https://source.unsplash.com/1600x900/?${keywords}`;
                    try {
                        const dataUrl = await fetchToDataUrl(placeholderUrl);
                        if (dataUrl) {
                            slide.addImage({ 
                                data: dataUrl, 
                                x: 5.8, y: yPos, w: 4, h: 3 
                            });
                        }
                    } catch (e) {
                        console.warn('Failed to load title-based placeholder:', e);
                    }
                }
        }

        // Speaker Notes
        // REMOVED as per user request to prevent corruption/issues
        // const notes = section.speakerNotes || findMatchingScript(videoScripts, section.title);
        // if (notes) {
        //    slide.addNotes(notes);
        // }

        // Footer
        slide.addText(`${course.title} | ${new Date().toLocaleDateString()}`, {
            x: 0.5, y: 6.8, w: '90%', h: 0.3,
            fontSize: 10, color: '9CA3AF', align: 'right'
        });
    }
};

const addSummarySlide = (pptx: PptxGenJS): void => {
    const slide = pptx.addSlide();
    slide.background = { color: 'F3F4F6' };

    slide.addText('Recapitulare', {
        x: 0.5, y: 1.5, w: '90%', h: 1,
        fontSize: 36, bold: true, color: '1F2937',
        align: 'center'
    });

    const summaryText = [
        'Mulțumim pentru participare!',
        'Continuați cu proiectele practice',
        'Descărcați cheat sheet-ul pentru referință rapidă',
        'Aplicați tehnicile învățate în următoarele 48h'
    ].join('\n');

    slide.addText(summaryText, {
        x: 0.5, y: 3, w: '90%', h: 3,
        fontSize: 20, bullet: true, color: '374151',
        align: 'center', lineSpacing: 32
    });
};

const fetchToDataUrl = async (url: string): Promise<string | null> => {
    try {
        const res = await fetch(url);
        if (!res.ok) return null;
        const blob = await res.blob();
        
        // Validate MIME type to prevent corrupting PPTX with HTML/Text
        if (!blob.type.startsWith('image/')) {
            console.warn(`[Export] Invalid image type for ${url}: ${blob.type}`);
            return null;
        }

        return await new Promise<string>((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result as string);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    } catch {
        return null;
    }
};

// ============================================================================
// PARSER FUNCTIONS
// ============================================================================

const parseContentSections = (markdown: string): ContentSection[] => {
    const sections: ContentSection[] = [];
    const lines = markdown.split('\n');

    // First pass: detect if the editor uses explicit "Slide nr:" markers
    const hasSlideMarkers = lines.some(l => /^\s*(\*\*|#+)?\s*Slide\s*(nr\.|#)?\s*\d+:/i.test(l.trim()));

    let currentTitle: string | null = null;
    let currentBuffer: string[] = [];

    const flush = () => {
        if (currentTitle && currentBuffer.length > 0) {
            processSlideBlock(currentTitle, currentBuffer.join('\n'), sections);
        }
        currentTitle = null;
        currentBuffer = [];
    };

    for (let i = 0; i < lines.length; i++) {
        const raw = lines[i];
        const line = raw.trim();

        // --- DETECT NEW SLIDE START (PRIORITIZE \"Slide nr:\") ---
        // Accept "Slide 1" with or without a title part, optional colon
        const slideMatch = line.match(/^(\*\*|#+)?\s*(Slide|幻灯片)\s*(nr\.|#)?\s*\d+(?:\s*[:：]\s*(.+?))?(\*\*|#+)?$/i);
        const headerMatch = !hasSlideMarkers ? line.match(/^(#{2,4})\s+(.+)$/) : null;
        // module headers intentionally ignored to avoid over-segmentation
        const hrMatch = (!hasSlideMarkers ? line.match(/^(\-{3,}|\*{3,})$/) : null);

        if (slideMatch || headerMatch || hrMatch) {
            flush();
            let rawTitle = '';
            if (slideMatch) rawTitle = (slideMatch[4] || 'Slide').toString();
            else if (headerMatch) rawTitle = headerMatch[2];
            else if (hrMatch) rawTitle = 'Slide';
            currentTitle = rawTitle.replace(/(\*\*|#+)$/, '').trim();
            continue;
        }

        if (currentTitle) {
            currentBuffer.push(raw);
        }
    }

    flush();
    return sections;
};

const sanitizeText = (text: string): string => {
    // Remove control characters that are not allowed in XML (0x00-0x08, 0x0B-0x0C, 0x0E-0x1F)
    // Keep tabs (0x09), newlines (0x0A), carriage returns (0x0D)
    return text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\uFFFE\uFFFF]/g, '');
};

const processSlideBlock = (title: string, contentBlock: string, sections: ContentSection[]) => {
    const lines = contentBlock.trim().split('\n');
    
    let currentMode: 'content' | 'notes' | 'visual' | null = null;
    let visualSearchTerm = '';
    let speakerNotes = '';
    let bulletPoints: string[] = [];
    let images: { url: string; alt: string }[] = [];
    let bodyTextParts: string[] = [];

    // Helper regex for strict mode detection
    const visualRegex = /^\s*[-*•_]*\s*(Visual|Imagine\s*Sugerată|Image|Visual\s*cue|Prompt|Vizual|视觉|图像|图片|图示|视觉提示|Visual|Imagem)\s*[:：\-]?\s*/i;
    const textRegex = /^\s*[-*•_]*\s*(Text|Content|Conținut|Texto|文本|内容)\s*[:：\-]?\s*/i;
    const notesRegex = /^\s*[-*•_]*\s*(Speaker\s*Notes|Note\s*Vorbit|Note\s*Trainer|讲者备注|讲者注释|演讲备注|旁白|Notas\s*do\s*Apresentador|Notas\s*do\s*Orador|Notas\s*do\s*Palestrante)\s*[:：\-]?\s*/i;
    const titleLabelRegex = /^\s*[-*•_]*\s*(Titlu|Subtitlu)\s*[:\-]?\s*/i;
    const imageLabelRegex = /^\s*[-*•_]*\s*(Imagine\s*Sugerată|Imagine|Visual)\s*[:\-]?\s*/i;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;

        // --- FILTER OUT NOISE ---
        // If the line looks like a Slide title or Module header that slipped in (handling bold/headers)
        if (/^(\*\*|#+)?\s*(Slide|Modul[e]?)\s*#?\s*\d+:/i.test(line)) continue;
        if (line.startsWith('---')) continue;

        // --- DETECT MODE SWITCHERS ---
        // Handle "Label: Content" on the same line
        if (visualRegex.test(line)) {
            currentMode = 'visual';
            const content = line.replace(visualRegex, '').trim();
            if (content) visualSearchTerm = content;
            continue;
        }

        if (textRegex.test(line)) {
            currentMode = 'content';
            const content = line.replace(textRegex, '').trim();
            // If there is content on the same line, process it immediately
            if (content) {
                if (content.startsWith('- ') || content.startsWith('* ') || content.startsWith('• ')) {
                    bulletPoints.push(content.replace(/^[-*•]\s+/, '').trim());
                } else {
                    bodyTextParts.push(content);
                }
            }
            continue;
        }

        if (notesRegex.test(line)) {
            currentMode = 'notes';
            // User requested to IGNORE speaker notes completely for export
            // We just switch mode to 'notes' so subsequent lines are skipped
            continue;
        }

        // --- PROCESS LINE BASED ON MODE ---
        if (currentMode === 'visual') {
            if (!visualSearchTerm) visualSearchTerm = line;
            else visualSearchTerm += ' ' + line;
        } else if (currentMode === 'notes') {
            // IGNORE NOTES CONTENT as requested
            continue; 
        } else if (currentMode === 'content') {
            // Content Mode
            if (line.toLowerCase().includes('layout:')) continue;
            // Ignore labels that should never become content
            if (titleLabelRegex.test(line)) continue;
            if (imageLabelRegex.test(line)) continue;
            if (visualRegex.test(line)) { currentMode = 'visual'; continue; }
            if (notesRegex.test(line)) { currentMode = 'notes'; continue; }

            // Check for bullets
            if (line.startsWith('- ') || line.startsWith('* ') || line.startsWith('• ')) {
                bulletPoints.push(line.replace(/^[-*•]\s+/, '').trim());
            } else if (/^\d+\./.test(line)) {
                bulletPoints.push(line.replace(/^\d+\.\s+/, '').trim());
            } else if (line.startsWith('![')) {
                const match = line.match(/!\[([^\]]*)\]\(([^)]+)\)/);
                if (match) images.push({ alt: match[1], url: match[2] });
            } else {
                // Regular text line
                // Aggressively filter out things that look like metadata keys if they lack the colon
                if (line.length > 2) {
                    bodyTextParts.push(line);
                }
            }
        } else {
            // Before \"Text:\" we ignore content-only lines to avoid capturing labels or noise
            continue;
        }
    }

    // Post-processing: If visual search term contains the description "Photo of...", keep it.
    // Unsplash search logic in addContentSlides handles keyword extraction.

    if (bulletPoints.length === 0 && bodyTextParts.length > 0) {
         bulletPoints = bodyTextParts;
         bodyTextParts = [];
    }

    // LIMIT CONTENT DENSITY
    // If we have too many bullets, take the first 7 to prevent overflow
    if (bulletPoints.length > 7) {
        bulletPoints = bulletPoints.slice(0, 7);
    }

    // Clean up bullets that might have captured labels/headers
    bulletPoints = bulletPoints.filter(b => 
        !/^(Slide|Modul[e]?)\s*#?\s*\d+:/i.test(b) &&
        !/^---$/.test(b) &&
        !/^\s*(Titlu|Subtitlu|Imagine\s*Sugerată|Speaker\s*Notes)\s*[:\-]?/i.test(b)
    );

    // SANITIZE TEXT to prevent XML corruption
    const cleanTitle = sanitizeText(title.replace(/^(Slide|Modul[e]?)\s*#?\s*\d+:\s*/i, '').trim());
    const cleanBullets = bulletPoints.map(sanitizeText);
    const cleanBody = sanitizeText(bodyTextParts.join('\n'));
    const cleanNotes = sanitizeText(speakerNotes);

    let finalTitle = cleanTitle;
    if (!finalTitle || /^slide(\s*\d+)?$/i.test(finalTitle)) {
        finalTitle = cleanBullets[0] || (cleanBody.split('\n').filter(Boolean)[0] || 'Slide');
    }

    sections.push({
        title: finalTitle,
        bulletPoints: cleanBullets,
        images,
        rawContent: contentBlock,
        bodyText: cleanBody,
        visualSearchTerm,
        speakerNotes: cleanNotes
    });
};

const parseVideoScripts = (markdown: string): Record<string, string> => {
    const scripts: Record<string, string> = {};
    const lessons = markdown.split(/\n(?=## )/);

    for (const lesson of lessons) {
        const titleMatch = lesson.match(/^##\s*(.+)/m);
        if (!titleMatch) continue;

        const title = titleMatch[1].trim();
        const audioMatches = lesson.matchAll(/\[AUDIO\]\s*(.+?)(?=\[VISUAL\]|\n\n|$)/gs);
        const audioContent = Array.from(audioMatches)
            .map(m => m[1].trim())
            .join('\n\n');

        if (audioContent) {
            scripts[title] = audioContent;
        }
    }

    return scripts;
};

const findMatchingScript = (
    scripts: Record<string, string>,
    slideTitle: string
): string | null => {
    if (scripts[slideTitle]) {
        return scripts[slideTitle];
    }

    const keywords = slideTitle.toLowerCase().split(' ').filter(w => w.length > 3);
    for (const [scriptTitle, content] of Object.entries(scripts)) {
        const matches = keywords.filter(kw =>
            scriptTitle.toLowerCase().includes(kw)
        );
        if (matches.length >= 2) {
            return content;
        }
    }

    return null;
};

const extractIntroScript = (markdown: string): string => {
    const introMatch = markdown.match(/\[AUDIO\]\s*(.+?)(?=\[VISUAL\]|\n##|$)/s);
    return introMatch ? introMatch[1].trim() : '';
};

const parseModulesFromStructure = (markdown: string): string => {
    const lines = markdown.split('\n');
    const modules: string[] = [];

    for (const line of lines) {
        if (line.match(/^(Modul|Module)\s+\d+:/i)) {
            modules.push(line.trim());
        } else if (line.match(/^\s*[*-]\s+\*\*Lecția/i)) {
            modules.push('  ' + line.trim().replace(/^\s*[*-]\s+/, ''));
        }
    }

    return modules.length > 0 ? modules.join('\n') : 'Structura cursului va fi detaliată în lecțiile următoare.';
};

const generateModulesFromSteps = (steps: CourseStep[]): string => {
    return steps
        .filter(s => !shouldExcludeFromSlides(s))
        .map((s, i) => `${i + 1}. ${s.title_key}`)
        .join('\n');
};

const shouldExcludeFromSlides = (step: CourseStep): boolean => {
    const excludedKeys = ['structure', 'video_scripts', 'tests', 'cheat_sheets'];
    return excludedKeys.some(key => step.title_key.toLowerCase().includes(key));
};

const findStepByKey = (course: Course, keyPattern: string): CourseStep | null => {
    return course.steps?.find(s =>
        s.title_key.toLowerCase().includes(keyPattern.toLowerCase())
    ) || null;
};

// ============================================================================
// MAIN EXPORT FUNCTIONS
// ============================================================================

const exportCourseAsPptxV2 = async (course: Course): Promise<void> => {
    const pptx = new PptxGenJS();
    pptx.layout = 'LAYOUT_16x9';

    // 1. Title Slide
    addTitleSlide(pptx, course);

    // 2. Agenda Slide
    const structureStep = findStepByKey(course, 'structure');
    const videoScriptStep = findStepByKey(course, 'video_scripts');
    addAgendaSlide(pptx, course, structureStep, videoScriptStep);

    // 3. Content Slides
    // Only process the specific "Slides" step to avoid including Manual, Quiz, etc.
    // Try explicit keys first, then fallback to partial match
    const slidesStep = course.steps?.find(s => 
        s.title_key === 'course.steps.slides' || 
        s.title_key === 'livrables.slides'
    ) || course.steps?.find(s => 
        s.title_key.toLowerCase().includes('slides')
    );

    const stepsToExport = slidesStep ? [slidesStep] : (course.steps || []).filter(s => !shouldExcludeFromSlides(s));

    // Parallel Processing Configuration
    const MAX_CONCURRENCY = 3; // Limit concurrent AI/Image requests to avoid timeouts/rate-limits

    for (const step of stepsToExport) {
        if (step.content) {
            // Pre-process content
            const pre = normalizeExternalImageLinks(step.content);
            const withPublic = await replaceBlobUrlsWithPublic(pre, course.user_id, course.id);
            const sections = parseContentSections(withPublic);

            // Process sections in batches to avoid browser hang
            for (let i = 0; i < sections.length; i += MAX_CONCURRENCY) {
                const batch = sections.slice(i, i + MAX_CONCURRENCY);
                
                await Promise.all(batch.map(async (section) => {
                    const slide = pptx.addSlide();
                    
                    // AI Analysis - BYPASSED FOR DETERMINISTIC PIPELINE
                    // We use the parsed content directly to avoid hallucinations and timeouts
                    // We still use getSmartFallbackDesign to rotate through templates
                    let aiDesign: SlideDesignJSON = getSmartFallbackDesign(section.rawContent);
                    
                    // Force the parsed title and content (Source of Truth)
                    aiDesign.title = section.title;
                    if (section.bulletPoints.length > 0) {
                        aiDesign.content = section.bulletPoints;
                    } else if (section.bodyText) {
                        aiDesign.content = section.bodyText
                            .split('\n')
                            .map(s => s.trim())
                            .filter(Boolean);
                    } else {
                        // Safety: If parser found no content, do not fallback to raw dump
                        aiDesign.content = [];
                    }

                    // Prioritize parsed visual search term if available
                    if (section.visualSearchTerm) {
                        aiDesign.imagePrompt = section.visualSearchTerm;
                    } else {
                        // If no visual term, use title as fallback prompt
                        aiDesign.imagePrompt = section.title;
                    }

                    // Image Search (Deterministic)
                    let imageUrl = '';
                    const finalPrompt = aiDesign.imagePrompt;
                    
                    if (finalPrompt) {
                         try {
                            // Extract keywords for better search results
                            const searchKeywords = finalPrompt.replace(/^(Photo of|Image of|Visual of)\s+/i, '').split(/[\s,]+/).slice(0, 4).join(' ');
                            
                            const searchPromise = searchImages(searchKeywords, 1);
                             const timeoutPromise = new Promise<never>((_, reject) => 
                                setTimeout(() => reject(new Error('Image Search Timeout')), 8000)
                            );
                            const images = await Promise.race([searchPromise, timeoutPromise]) as any[];

                            if (images && images.length > 0) {
                                imageUrl = images[0].url;
                            }
                         } catch (e) {
                             console.warn('Image search failed/timed out for slide:', section.title);
                         }
                    }
                    
                    // Fallback to embedded image
                    if (!imageUrl && section.images.length > 0) {
                        imageUrl = section.images[0].url;
                    }

                    // CRITICAL: Convert all external images to Base64 to prevent PowerPoint corruption (Repair Prompt)
                    // PowerPoint often blocks or errors on external HTTP links (CORS, 403, etc.)
                    if (imageUrl && !imageUrl.startsWith('data:')) {
                        try {
                            const dataUrl = await fetchToDataUrl(imageUrl);
                            if (dataUrl) {
                                imageUrl = dataUrl;
                            } else {
                                console.warn('Failed to convert image to Base64, removing to prevent corruption:', imageUrl);
                                imageUrl = ''; 
                            }
                        } catch (e) {
                             console.warn('Exception converting image to Base64:', e);
                             imageUrl = '';
                        }
                    }

                    // Helper: choose layout depending on image presence
                    const chooseLayoutForContent = (hasImage: boolean, desired: SlideDesignJSON['layout']): SlideDesignJSON['layout'] => {
                        const imageLayouts: SlideDesignJSON['layout'][] = [
                            'HERO','SPLIT_LEFT','SPLIT_RIGHT','FULL_IMAGE','IMAGE_CENTER','IMAGE_SIDEBAR'
                        ];
                        const textLayouts: SlideDesignJSON['layout'][] = [
                            'DEFAULT','TRIAD','THREE_COLUMNS','COMPARISON','TIMELINE',
                            'SECTION_HEADER','CHECKLIST','DO_DONT','PROCESS_STEPS','KEY_TAKEAWAYS','DATA_POINTS','QUOTE_CENTER','TABLE_SIMPLE','AGENDA_COMPACT'
                        ];
                        const pool = hasImage ? imageLayouts : textLayouts;
                        // If desired fits pool, keep it; otherwise pick from pool by simple rotation
                        if (pool.includes(desired)) return desired;
                        const idx = Math.floor(Math.random() * pool.length);
                        return pool[idx];
                    };

                    aiDesign.layout = chooseLayoutForContent(!!imageUrl, aiDesign.layout);

                    // Render based on Layout
                    try {
                        switch (aiDesign.layout) {
                            case 'HERO': renderHeroSlide(slide, aiDesign, imageUrl); break;
                            case 'SPLIT_LEFT': renderSplitLeft(slide, aiDesign, imageUrl); break;
                            case 'SPLIT_RIGHT': renderSplitRight(slide, aiDesign, imageUrl); break;
                            case 'BIG_STAT': renderBigStat(slide, aiDesign, imageUrl); break;
                            case 'COMPARISON': renderComparison(slide, aiDesign, imageUrl); break;
                            case 'QUOTATION': renderQuotation(slide, aiDesign, imageUrl); break;
                            case 'TRIAD': renderTriad(slide, aiDesign, imageUrl); break;
                            case 'TIMELINE': renderTimeline(slide, aiDesign, imageUrl); break;
                            case 'FULL_IMAGE': renderFullImage(slide, aiDesign, imageUrl); break;
                            case 'GRID_CARDS': renderGridCards(slide, aiDesign, imageUrl); break;
                            case 'IMAGE_CENTER': renderImageCenter(slide, aiDesign, imageUrl); break;
                            case 'THREE_COLUMNS': renderThreeColumns(slide, aiDesign, imageUrl); break;
                            case 'SECTION_HEADER': renderSectionHeader(slide, aiDesign, imageUrl); break;
                            case 'CHECKLIST': renderChecklist(slide, aiDesign, imageUrl); break;
                            case 'DO_DONT': renderDoDont(slide, aiDesign, imageUrl); break;
                            case 'PROCESS_STEPS': renderProcessSteps(slide, aiDesign, imageUrl); break;
                            case 'KEY_TAKEAWAYS': renderKeyTakeaways(slide, aiDesign, imageUrl); break;
                            case 'DATA_POINTS': renderDataPoints(slide, aiDesign, imageUrl); break;
                            case 'QUOTE_CENTER': renderQuoteCenter(slide, aiDesign, imageUrl); break;
                            case 'TABLE_SIMPLE': renderTableSimple(slide, aiDesign, imageUrl); break;
                            case 'IMAGE_SIDEBAR': renderImageSidebar(slide, aiDesign, imageUrl); break;
                            case 'AGENDA_COMPACT': renderAgendaCompact(slide, aiDesign, imageUrl); break;
                            case 'DEFAULT': 
                            default: renderDefault(slide, aiDesign, imageUrl); break;
                        }

                        // Add Speaker Notes - DISABLED
                        // if (section.speakerNotes) {
                        //    slide.addNotes(section.speakerNotes);
                        // }
                        
                        // Footer
                        slide.addText(`${course.title} | ${new Date().toLocaleDateString()}`, {
                            x: 0.5, y: 6.8, w: '90%', h: 0.3,
                            fontSize: 10, color: '9CA3AF', align: 'right'
                        });

                    } catch (renderErr) {
                         console.error('Error rendering slide:', renderErr);
                         // Fallback render to ensure slide isn't empty if complex render fails
                         renderDefault(slide, aiDesign, imageUrl);
                    }
                }));
            }
        }
    }

    // 4. Summary Slide
    addSummarySlide(pptx);

    const fileName = `${course.title.replace(/[^a-z0-9]/gi, '_')}_AI.pptx`;
    await pptx.writeFile({ fileName });
};

export const exportCourseAsPptx = async (course: Course): Promise<void> => {
    // ALWAYS use V2 exporter as it contains the critical fixes for PPTX corruption and content parsing
    // if (isEnabled('newPptxExporter')) {
        try {
            await exportCourseAsPptxV2(course);
            return;
        } catch (e) {
            console.warn('[Export] V2 exporter failed, falling back to legacy:', e);
        }
    // }
    const pptx = new PptxGenJS();
    pptx.layout = 'LAYOUT_16x9';

    addTitleSlide(pptx, course);

    const structureStep = findStepByKey(course, 'structure');
    const videoScriptStep = findStepByKey(course, 'video_scripts');
    addAgendaSlide(pptx, course, structureStep, videoScriptStep);

    for (const step of course.steps || []) {
        if (!shouldExcludeFromSlides(step) && step.content) {
            await addContentSlides(pptx, step, course);
        }
    }

    addSummarySlide(pptx);

    const fileName = `${course.title.replace(/[^a-z0-9]/gi, '_')}.pptx`;
    await pptx.writeFile({ fileName });
};

const linkSlideModelsToBlueprint = (course: Course, models: SlideModel[]): SlideModel[] => {
    const bp = course.blueprint;
    if (!bp || !Array.isArray(bp.modules)) return models;
    const byTitle: Record<string, { sectionId: string; objective: string }> = {};
    for (const m of bp.modules) {
        for (const s of m.sections || []) {
            const k = (s.title || '').toLowerCase().trim();
            if (!k) continue;
            byTitle[k] = { sectionId: s.id, objective: m.learning_objective };
        }
    }
    return models.map(mm => {
        const t = (mm.title || '').toLowerCase().trim();
        const link = byTitle[t];
        if (!link) return mm;
        const objective_links = Array.isArray(mm.objective_links) ? mm.objective_links : [];
        const nextObj = link.objective ? [link.objective] : objective_links;
        return { ...mm, section_id: link.sectionId, objective_links: nextObj };
    });
};

export const getSlideModelsForPreview = async (course: Course): Promise<SlideModel[]> => {
    // 1. Try to find explicit slide content (Source of Truth)
    // Prioritize 'livrables.slides'
    let slidesStep = course.steps?.find(s => s.title_key === 'livrables.slides');
    
    if (!slidesStep) {
        slidesStep = course.steps?.find(s => 
            s.title_key.toLowerCase().includes('slides')
        );
    }

    const videoScriptStep = findStepByKey(course, 'video_scripts');
    const scripts = videoScriptStep ? parseVideoScripts(videoScriptStep.content) : {};

    if (slidesStep && slidesStep.content && slidesStep.content.length > 50) {
        const contentWithPublic = await replaceBlobUrlsWithPublic(slidesStep.content, course.user_id, course.id);
        const contentAllPublic = await ensurePublicExternalImages(contentWithPublic, course.user_id, course.id);
        
        // Use our robust parser WITHOUT linking to blueprint to avoid "ghost" modules overriding explicit slides
        let models = buildSlideModelsFromContent(contentAllPublic, slidesStep.title_key, scripts);
        
        // Do NOT link to blueprint here. We want exactly what is in the editor.
        // models = linkSlideModelsToBlueprint(course, models); 
        
        return models;
    }
    
    // Fallback logic
    let models = buildSlideModelsFromCourse(course, scripts);
    models = linkSlideModelsToBlueprint(course, models);
    return models;
};

export const getPedagogicWarnings = (m: SlideModel): string[] => {
    const rules = getTemplateRules(m.slide_type);
    const warnings: string[] = [];
    const titleLen = (m.title || '').length;
    if (rules.maxTitleChars && titleLen > rules.maxTitleChars) warnings.push('[WARN] Titlu prea lung pentru arhetip');
    const bullets = m.bullets || [];
    if (rules.maxBullets && bullets.length > rules.maxBullets) warnings.push('[WARN] Prea multe bullets');
    const maxLen = rules.maxBulletLength ?? null;
    if (maxLen !== null && bullets.some(b => b.length > maxLen)) warnings.push('[WARN] Bullets prea lungi');

    const density = ((m.title || '').length) + bullets.reduce((acc, b) => acc + b.length, 0);
    if (density > 1000) warnings.push('[WARN] Conținut prea dens pentru un singur slide');

    if (m.slide_type === SlideArchetype.ImageText && !m.image_url) warnings.push('[CRITICAL] Lipsește imaginea la Image+Text');

    const textAll = ((m.title || '') + ' ' + bullets.join(' ')).toLowerCase();
    const BLOOM = {
        remember: ['definește', 'defini', 'enumeră', 'listează', 'identifică', 'recunoaște', 'descrie', 'menționează'],
        understand: ['explică', 'interpretează', 'clarifică', 'rezumă', 'exemplifică', 'parafrazează', 'ilustrează'],
        apply: ['aplică', 'utilizează', 'folosește', 'implementează', 'exersează', 'execută', 'proiectează', 'realizează'],
        analyze: ['analizează', 'compară', 'descompune', 'relatează', 'examinează', 'categorizează', 'corelează'],
        evaluate: ['evaluează', 'argumentează', 'justifică', 'critică', 'decide', 'apreciază', 'verifică'],
        create: ['creează', 'sintetizează', 'compune', 'inovează', 'construiește', 'elaborează', 'proiectează']
    } as const;
    const bloomOrder = ['remember', 'understand', 'apply', 'analyze', 'evaluate', 'create'] as const;
    const detectBloomLevel = (t: string): number => {
        for (let i = bloomOrder.length - 1; i >= 0; i--) {
            const level = bloomOrder[i];
            const verbs = BLOOM[level];
            if (verbs.some(v => t.includes(v))) return i;
        }
        return -1;
    };
    const minLevelForArchetype = (a: SlideArchetype): number => {
        if (a === SlideArchetype.Exercise) return bloomOrder.indexOf('apply');
        if (a === SlideArchetype.CaseStudy) return bloomOrder.indexOf('analyze');
        if (a === SlideArchetype.Summary) return bloomOrder.indexOf('understand');
        if (a === SlideArchetype.Explainer) return bloomOrder.indexOf('understand');
        if (a === SlideArchetype.ImageText) return bloomOrder.indexOf('understand');
        return bloomOrder.indexOf('remember');
    };
    const bloomDetected = detectBloomLevel(textAll);
    const bloomRequired = minLevelForArchetype(m.slide_type);
    if (bloomDetected >= 0 && bloomDetected < bloomRequired) warnings.push('[WARN] Nivel Bloom prea scăzut pentru arhetip');

    if (m.slide_type === SlideArchetype.Exercise) {
        if (bullets.length < 3) warnings.push('[CRITICAL] Exercițiu fără pași suficienți');
        const hasApply = BLOOM.apply.some(v => textAll.includes(v));
        if (!hasApply) warnings.push('[WARN] Exercițiul ar trebui să ceară aplicare');
    }

    if (m.slide_type === SlideArchetype.CaseStudy) {
        const keys = ['context', 'problemă', 'soluție', 'rezultat'];
        const hits = keys.filter(k => textAll.includes(k)).length;
        if (hits < 2) warnings.push('[WARN] Studiu de caz fără structură clară');
        const hasEvaluate = BLOOM.evaluate.some(v => textAll.includes(v));
        if (!hasEvaluate) warnings.push('[INFO] Adaugă evaluare/concluzii pentru un studiu de caz robust');
    }

    if (m.slide_type === SlideArchetype.Summary) {
        const integrationHints = ['reflectă', 'plan', 'transfer', 'integrează', 'recapitulare', 'reține'];
        const hasIntegration = integrationHints.some(v => textAll.includes(v));
        if (!hasIntegration) warnings.push('[INFO] Îndeamnă la reflecție/plan de acțiune în rezumat');
    }

    return warnings;
};

const splitSentences = (text: string): string[] => {
    const clean = text.replace(/\s+/g, ' ').trim();
    if (!clean) return [];
    const parts = clean.split(/(?<=[.!?])\s+/);
    return parts.map(p => p.replace(/^[*•-]\s*/, '').trim()).filter(Boolean);
};

const deriveBulletsFromBody = (body: string): string[] => {
    const sents = splitSentences(body);
    return sents.slice(0, 6);
};

// V2 exporter: builds SlideModel IR and renders archetypes deterministically
const buildSlideModelsFromCourse = (course: Course, scripts: Record<string, string>): SlideModel[] => {
    const models: SlideModel[] = [];
    const steps = course.steps || [];
    for (const step of steps) {
        if (shouldExcludeFromSlides(step) || !step.content) continue;
        const sections = parseContentSections(step.content);
        sections.forEach((s, idx) => {
            const id = `${step.id}_sec_${idx + 1}`;
            const baseBullets = s.bulletPoints.length > 0 ? s.bulletPoints : deriveBulletsFromBody(s.bodyText || '');
            const image = s.images[0]?.url || null;
            const archetype = chooseArchetypeFor(step.title_key, s.title, image);
            const rules = getTemplateRules(archetype);
            let m: SlideModel = {
                id,
                slide_type: archetype,
                title: s.title,
                bullets: baseBullets,
                image_url: image,
                section_id: undefined,
                objective_links: [],
                trainer_notes: null,
            };
            m = normalizeSlide(m, rules);
            const note = findMatchingScript(scripts, s.title);
            if (note) m.trainer_notes = note;
            const valid = validateSlide(m, rules);
            if (!valid) {
                const fallbackRules = getTemplateRules(SlideArchetype.Explainer);
                m.slide_type = SlideArchetype.Explainer;
                m = normalizeSlide(m, fallbackRules);
            }
            models.push(m);
        });
    }
    return models;
};


const buildSlideModelsFromContent = (markdown: string, titleKey: string, scripts: Record<string, string>): SlideModel[] => {
    const models: SlideModel[] = [];
    const sections = parseContentSections(markdown);
    sections.forEach((s, idx) => {
        const id = `${titleKey}_sec_${idx + 1}`;
        const image = s.images[0]?.url || null;
        const archetype = chooseArchetypeFor(titleKey, s.title, image);
        const rules = getTemplateRules(archetype);
        let m: SlideModel = {
            id,
            slide_type: archetype,
            title: s.title,
            bullets: s.bulletPoints.length > 0 ? s.bulletPoints : (s.bodyText ? s.bodyText.split('\n') : []),
            image_url: image,
            image_prompt: s.visualSearchTerm,
            section_id: undefined,
            objective_links: [],
            trainer_notes: s.speakerNotes || null,
        };
        m = normalizeSlide(m, rules);
        const note = findMatchingScript(scripts, s.title);
        if (note && !m.trainer_notes) m.trainer_notes = note; // Only use script if no specific notes found
        const valid = validateSlide(m, rules);
        if (!valid) {
            const fallbackRules = getTemplateRules(SlideArchetype.Explainer);
            m.slide_type = SlideArchetype.Explainer;
            m = normalizeSlide(m, fallbackRules);
        }
        models.push(m);
    });
    return models;
};



const TEMPLATE_RULES: Record<SlideArchetype, SlideRules> = {
    [SlideArchetype.Title]: { maxTitleChars: 60 },
    [SlideArchetype.Explainer]: { maxTitleChars: 60, maxBullets: 5, maxBulletLength: 110 },
    [SlideArchetype.ImageText]: { maxTitleChars: 60, maxBullets: 4, maxBulletLength: 100, requiresImage: true },
    [SlideArchetype.Quote]: { maxTitleChars: 120 },
    [SlideArchetype.Agenda]: { maxBullets: 8, maxBulletLength: 80 },
    [SlideArchetype.Exercise]: { maxTitleChars: 80, maxBullets: 6, maxBulletLength: 120 },
    [SlideArchetype.CaseStudy]: { maxTitleChars: 80, maxBullets: 5, maxBulletLength: 120 },
    [SlideArchetype.Summary]: { maxBullets: 5, maxBulletLength: 80 },
};

export const getTemplateRules = (a: SlideArchetype): SlideRules => TEMPLATE_RULES[a] || { maxTitleChars: 60 };

const trimTo = (s: string, n: number): string => (s.length > n ? (s.slice(0, Math.max(0, n - 3)) + '…') : s);

export const normalizeSlide = (m: SlideModel, r: SlideRules): SlideModel => {
    const title = m.title ? (r.maxTitleChars ? trimTo(m.title, r.maxTitleChars) : m.title) : m.title;
    const maxB = typeof r.maxBullets === 'number' ? r.maxBullets : undefined;
    const clipBullets = (m.bullets || []).slice(0, maxB || (m.bullets || []).length).map(b => {
        const lim = r.maxBulletLength || 9999;
        return trimTo(b, lim);
    });
    const image = r.requiresImage ? (m.image_url || null) : (m.image_url || null);
    return { ...m, title, bullets: clipBullets, image_url: image };
};

export const validateSlide = (m: SlideModel, r: SlideRules): boolean => {
    if (r.maxTitleChars && (m.title || '').length > r.maxTitleChars) return false;
    if (r.maxBullets && (m.bullets || []).length > r.maxBullets) return false;
    const maxLen = r.maxBulletLength ?? null;
    if (maxLen !== null && (m.bullets || []).some(b => b.length > maxLen)) return false;
    if (r.requiresImage && !m.image_url) return false;
    const density = ((m.title || '').length) + (m.bullets || []).reduce((acc, b) => acc + b.length, 0);
    if (density > 1200) return false;
    return true;
};

export const chooseArchetypeFor = (titleKey: string, sectionTitle: string, imageUrl: string | null): SlideArchetype => {
    const tk = titleKey.toLowerCase();
    const st = sectionTitle.toLowerCase();
    if (tk.includes('exercise') || st.includes('exerci')) return SlideArchetype.Exercise;
    if (tk.includes('case') || st.includes('studiu')) return SlideArchetype.CaseStudy;
    if (tk.includes('summary') || tk.includes('recap') || st.includes('rezumat')) return SlideArchetype.Summary;
    if (tk.includes('quote') || st.includes('citat')) return SlideArchetype.Quote;
    if (imageUrl) return SlideArchetype.ImageText;
    return SlideArchetype.Explainer;
};

// ============================================================================
// LEGACY EXPORTS
// ============================================================================

const normalizeMarkdownImages = (md: string): string => md.replace(/!\[([^\]]*)\]\s*\n\s*\(([^)]+)\)/g, '![$1]($2)');

const base64ToUint8Array = (base64: string): Uint8Array => {
    const binary = atob(base64);
    const bytes = new Uint8Array(binary.length);
    for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
    return bytes;
};

const fetchImageBytes = async (url: string): Promise<Uint8Array | null> => {
    try {
        if (url.startsWith('data:')) {
            const payload = url.split('base64,')[1] || '';
            if (!payload) return null;
            return base64ToUint8Array(payload);
        }
        const res = await fetch(url);
        if (!res.ok) return null;
        const buf = await res.arrayBuffer();
        return new Uint8Array(buf);
    } catch {
        return null;
    }
};

const parseTextToRuns = (text: string): TextRun[] => {
    const runs: TextRun[] = [];
    const parts = text.split(/(\*\*.*?\*\*)/g);
    parts.forEach(part => {
        if (part.startsWith('**') && part.endsWith('**')) {
            runs.push(new TextRun({ text: part.slice(2, -2), bold: true }));
        } else if (part) {
            runs.push(new TextRun(part));
        }
    });
    return runs;
};

const createDocxTable = (lines: string[]): Table | null => {
    try {
        const rows = lines.map(line => {
            const content = line.trim().replace(/^\|/, '').replace(/\|$/, '');
            return content.split('|').map(c => c.trim());
        });

        if (rows.length < 2) return null;

        const headers = rows[0];
        const dataRows = rows.slice(2); // Skip separator row

        const tableRows: TableRow[] = [];

        // Header
        tableRows.push(new TableRow({
            tableHeader: true,
            children: headers.map(h => new TableCell({
                children: [new Paragraph({
                    children: [new TextRun({ text: h, bold: true })],
                    alignment: AlignmentType.CENTER
                })],
                shading: { fill: "F3F4F6" },
                verticalAlign: "center",
                borders: {
                    top: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
                    bottom: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
                    left: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
                    right: { style: BorderStyle.SINGLE, size: 1, color: "000000" },
                }
            }))
        }));

        // Body
        dataRows.forEach(row => {
            const cells = row.map(cellText => new TableCell({
                children: [new Paragraph({ children: parseTextToRuns(cellText) })],
                borders: {
                    top: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                    bottom: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                    left: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                    right: { style: BorderStyle.SINGLE, size: 1, color: "CCCCCC" },
                }
            }));
            tableRows.push(new TableRow({ children: cells }));
        });

        return new Table({
            rows: tableRows,
            width: { size: 100, type: WidthType.PERCENTAGE },
        });
    } catch (e) {
        console.warn('Failed to parse table:', e);
        return null;
    }
};

const buildDocxParagraphs = async (content: string): Promise<(Paragraph | Table)[]> => {
    const children: (Paragraph | Table)[] = [];
    const lines = normalizeMarkdownImages(content).split('\n');
    const imageRegex = /!\[([^\]]*)\]\(([^)]+)\)/;

    let i = 0;
    while (i < lines.length) {
        const line = lines[i];
        const trimmed = line.trim();

        // Detect Table
        if (trimmed.startsWith('|') && i + 1 < lines.length) {
            const nextLine = lines[i + 1].trim();
            if (nextLine.startsWith('|') && nextLine.includes('---')) {
                const tableLines: string[] = [];
                while (i < lines.length && lines[i].trim().startsWith('|')) {
                    tableLines.push(lines[i]);
                    i++;
                }
                const table = createDocxTable(tableLines);
                if (table) {
                    children.push(table);
                } else {
                    tableLines.forEach(l => children.push(new Paragraph({ text: l })));
                }
                continue;
            }
        }

        const match = line.match(imageRegex);
        if (match) {
            const alt = match[1] || '';
            const url = match[2];
            const bytes = await fetchImageBytes(url);
            if (bytes) {
                children.push(new Paragraph({ children: [new ImageRun({ data: bytes, transformation: { width: 480, height: 360 } })] }));
            } else {
                children.push(new Paragraph({ children: [new TextRun(`Image: ${alt}`)] }));
            }
            i++;
            continue;
        }

        if (line.startsWith('# ')) {
            children.push(new Paragraph({ text: line.substring(2), heading: HeadingLevel.HEADING_1, alignment: AlignmentType.CENTER }));
        } else if (line.startsWith('## ')) {
            children.push(new Paragraph({ text: line.substring(3), heading: HeadingLevel.HEADING_2 }));
        } else if (line.startsWith('### ')) {
            children.push(new Paragraph({ text: line.substring(4), heading: HeadingLevel.HEADING_3 }));
        } else if (line.startsWith('* ') || line.startsWith('- ')) {
            children.push(new Paragraph({ text: line.substring(2), bullet: { level: 0 } }));
        } else if (trimmed === '') {
            children.push(new Paragraph({ text: '' }));
        } else {
            children.push(new Paragraph({ children: parseTextToRuns(line) }));
        }
        i++;
    }
    return children;
};

const createDocx = async (step: CourseStep, courseTitle: string, stepTitle: string): Promise<Blob> => {
    const pre = normalizeExternalImageLinks(step.content);
    const withPublic = await replaceBlobUrlsWithPublic(pre, step.user_id || null, step.course_id || null);
    const children = await buildDocxParagraphs(withPublic);
    const doc = new Document({
        sections: [{
            headers: {
                default: new Header({
                    children: [
                        new Paragraph({
                            children: [
                                new TextRun({ text: `${courseTitle} - ${stepTitle}`, size: 18, color: "888888" }),
                            ],
                            alignment: AlignmentType.RIGHT,
                        }),
                    ]
                }),
            },
            children,
        }],
    });
    return Packer.toBlob(doc);
};

export const exportCourseAsZip = async (course: Course, t: (key: string) => string): Promise<void> => {
    console.log('[Export] Starting zip export for:', course.title);
    const zip = new JSZip();

    for (const step of course.steps || []) {
        const stepTitle = t(step.title_key).replace(/^\d+\.\s*/, '');
        const blob = await createDocx(step, course.title, stepTitle);
        const fileName = `${stepTitle}.docx`;
        zip.file(fileName, blob);
    }

    // Generate ZIP with proper MIME type
    const zipBlob = await zip.generateAsync({
        type: 'blob',
        mimeType: 'application/zip'
    });

    const safeCourseTitle = course.title.replace(/[^a-z0-9]/gi, '_');
    const finalFileName = `course_${safeCourseTitle}.zip`;

    console.log('[Export] Zip generated, triggering download for:', finalFileName);

    // Trigger download using standard approach
    const url = URL.createObjectURL(zipBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = finalFileName;
    link.style.display = 'none';
    document.body.appendChild(link);
    link.click();

    // Cleanup
    setTimeout(() => {
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }, 100);
};

// Re-export PDF export function
export { exportCourseAsPdf };

// Debug/testing export for parser
export { parseContentSections as __debugParseContentSections };
